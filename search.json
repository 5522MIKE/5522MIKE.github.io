[{"title":"数据库总结","url":"/2021/10/13/数据库/","content":"\n背书专用\n\n<!--more-->\n\n## 绪论\n### 数据管理的三个阶段\n* 人工管理阶段\n* 文件系统阶段\n* 数据库系统阶段\n### 基本术语\n* 数据（Data）\n    * 计算机用来描述事物的记录（文字．图形．图像．声音）\n    * 数据的形式本身并不能完全表达其内容，需要经过语义解释。数据与其语义是不可分的\n* 数据库（Database，简称DB）\n    * 数据库是长期存储在计算机内有结构的大量的共享的数据集合。\n* 数据库管理系统（DBMS）\n    * 数据库管理系统是位于用户与操作系统之间的一层数据管理软件。\n    * 数据库在建立、运用和维护时由数据库管理系统统一管理、统一控制。\n    * 数据库系统（DBS）\n        * 数据库系统是指在计算机系统中引入数据库后的系统构成，一般由数据库、数据库管理系统（及其开发工具）、应用系统、数据库管理员和用户构成。 \n* 数据冗余度：\n    * 指同一数据重复存储时的重复程度。 \n* 数据的安全性（Security）\n    * 数据的安全性是指保护数据，防止不合法使用数据造成数据的泄密和破坏，使每个用户只能按规定，对某些数据以某些方式进行访问和处理。 \n* 数据的完整性（Integrity）\n    * 数据的完整性指数据的正确性、有效性和相容性。即将数据控制在有效的范围内，或要求数据之间满足一定的关系。 \n* 并发（Concurrency）控制\n    * 当多个用户的并发进程同时存取、修改数据库时，可能会发生相互干扰而得到错误的结果并使得数据库的完整性遭到破坏，因此必须对多用户的并发操作加以控制和协调。\n* 数据库恢复（Recovery）\n    * 计算机系统的硬件故障、软件故障、操作员的失误以及故意的破坏也会影响数据库中数据的正确性，甚至造成数据库部分或全部数据的丢失。DBMS必须具有将数据库从错误状态恢复到某一已知的正确状态（亦称为完整状态或一致状态）的功能。\n### 数据库的三要素\n* 数据（描述事物的符号记录，数据库里面存储的内容） \n* 存储器（外存，一般是硬盘，数据库的载体）\n* 数据库管理系统（DBMS，数据库的管理软件）\n### 数据模型\n* 模型\n    * 是现实世界特征的模拟和抽象\n* 数据模型\n    * 也是一种模型，它是现实世界数据特征的抽象，表示实体以及实体间的联系\n    * 一个用于描述数据、数据间关系、数据语义和数据约束的概念工具的集合\n* 两级模型的抽象\n    * 一是概念模型\n        * （也称信息模型，用于信息世界的建模），它是按用户的观点来对数据和信息建模，主要用于数据库设计。这类模型强调其语义表达能力，要能够较方便、直接地表达应用中的各种语义知识，这类模型应为概念简单、清晰、易于用户理解，是用户和数据库设计人员之间进行交流的语言。\n    * 二是数据模型\n        * （如层次、网状、关系模型，用于机器世界），它是按计算机系统的观点对数据建模，主要用于DBMS的实现。这类模型通常需要有严格的形式化定义，而且常常会加上一些限制或规定，以便于机器上的实现。还通常有一组严格定义了语法和语义的语言，人们可以使用它来定义、操纵数据库中的数据。\n* 数据模型的三要素\n    * （1） 数据结构\n        * 数据结构是所研究的对象类型（Object Type）的集合。这些对象是数据库的组成部分。一般可分为两类：一类是与数据类型、内容、性质有关的对象，如网状模型中的数据项、记录，关系模型中的属性、关系等；一类是与数据之间联系有关的对象，如网状模型中的系型（Set Type）等。\n    * （2） 数据操作\n        * 数据操作是指对数据库中各种对象（型）的实例（值）允许执行的操作的集合。数据库主要有检索和更新（插入、删除、修改）两大类操作。\n        *  数据结构是对系统静态特性的描述，数据操作是对系统动态特性的描述。\n    * （3） 数据的约束条件\n        * 数据的约束条件是完整性规则的集合。完整性规则是给定的数据模型中数据及其联系所具有的制约和依存规则，用以限定符合数据模型的数据状态以及状态的变化，以保证数据的正确、有效、相容。\n* 概念模型\n    * 实体（Entity）\n        * 客观存在并可相互区别的事物称为实体。实体可以是具体的人、事、物，也可以是抽象的概念或联系，如学生、部门、课程、银行帐户、选课、订货、演出、比赛等。\n    *  属性（Attribute）\n        * 实体所具有的某一特性称为属性。如学生实体可以由学号、姓名、性别、出生年月、系、入学时间等属性组成\n    * 码（关键字，Key）\n        * 唯一标识实体的（最小的）属性集称为码。例如学号学生实体的码\n    * 域（Domain）\n        * 属性的取值范围称为该属性的域。例如学号的域为8位整数，姓名的域为字符串集合，，性别的域为（男，女）。\n    * 实体型（Entity Type）\n        * 具有相同属性的实体必然具有共同的特征和性质。用实体名及其属性名集合来抽象和刻划同类实体，称为实体型。例如：学生（学号，姓名，性别，出生年月，系，入学时间）\n    * 实体集（Entity Set）\n        * 同型实体的集合称为实体集。例如，全体学生就是一个实体集。\n    * 联系（Relationship）\n        * 在现实世界中，事物内部以及事物之间是有联系的，这些联系在信息世界中反映为实体（型）内部的联系和实体（型）之间的联系。〖组成实体的各属性之间以及不同实体集之间的联系〗\n### 联系的种类\n* 1对1联系\n    * 定义：若对于实体集A中的每一个实体，实体集B中至多有一个实体与之联系，反之亦然，则称实体集A与实体集B具有一对一联系，记为1:1。\n* 1对多联系\n    * 定义：若对于实体集A中的每一个实体，实体集B中有n个实体(n≥0)与之联系，反之，对于对于实体集B中的每一个实体，实体集A中至多只有一个实体与之联系，则称实体集A与实体集B具有一对多联系，记为1:n\n* 多对多联系\n    * 定义：若对于实体集A中的每一个实体，实体集B中有n个实体(n≥0)与之联系，反之，对于对于实体集B中的每一个实体，实体集A中也有m个实体(m≥0)与之联系，则称实体集A与实体集B具有多对多联系，记为m:n\n### 概念模型的表示方法\n* E-R图\n    * 使用长方形来表示实体型，框内写上实体名\n    * 椭圆型表示实体的属性，并用无向边把实体和属性连接起来\n    * 用菱形表示实体间的联系，菱形框内写上联系名，用无向边把菱形分别与有关实体相连接，在无向边旁标上联系的类型，若实体之间联系也具有属性，则把属性和菱形也用无向边连接上\n    * \n### 基本数据模型\n* 层次模型(Hierarchical Model)\n    * 最早使用的一种模型\n    * 数据结构是一棵有向树\n    * 特点\n        * (1) 有且仅有一个结点无双亲，该结点称为根结点。\u000b\n        * (2) 其他结点有且只有一个双亲\n* 网状模型(Network Model)\n    * 数据结构是一个有向图\n    * 特点\n        * （1）有一个以上的结点没有双亲\u000b\n        * （2）结点可以有多于一个的双亲\n    * 能表示实体之间的多种复杂联系\n* 关系模型(Relational Model)\n    * 关系模型是用二维表格结构来表示实体及实体之间的联系的模型\n    * 数据结构是一个“二维表框架”组成的集合\n    * 关系模型概念简单,清晰,用户易懂易用,有严格的数学基础\n    * 大多数数据库系统都是关系型的\n    * 主要术语\n        * 关系：一个关系对应于我们平常讲的一张表\n        * 元组：表中的一行称为一个元组\n        * 属性：表中的一列称为属性，每列的名称为属性名\n        * 主码：表中的某个属性组，它们的值唯一的标识一个元组\n        * 域：属性的取值范围\n        * 分量：元组中的一个属性值\n        * 关系模式：对关系的描述，用关系名（属性名1，属性名2，…，属性名n）来表示\n    * 特点\n        * 1. 概念单一：\n            * 实体或实体之间的联系都用关系表示\n            * 用户的观点里，数据的逻辑结构就是表\n        * 2. 关系必须是规范化的关系\n            * 指在关系模型中，每一个关系模式要满足一定的要求或者称为规范条件\n            * 其最基本的要求是每一个分量是一个不可分的数据项，也就是说，不允许表中还有表。\n        * 3. 用户对数据的检索操作不过是从原来的表中得到一张新的表\n            * 在用户眼中，无论是原始数据还是结果数据，都是同一种数据结构——二维表。\n            * 数据操作是集合操作，即操作对象和操作结果都是若干元组的集合，而不象非关系模型中那样单记录的操作方式。\n            * 把存取路径向用户隐藏起来，提高了数据的独立性。\n### 数据库系统的体系结构\n* 三层模式：外模式、模式、内模式 \n    * 外模式\n        * 又称为用户模式，是数据库用户和数据库系统的接口，是数据库用户的数据视图，是数据库用户可以看见和使用的局部数据的逻辑结构和特征的描述\n        * 一个数据库通常都有多个外模式。一个应用程序只能使用一个外模式，但同一外模式可为多个应用程序所用\n    * 模式\n        * 可细分为概念模式和逻辑模式，是所有数据库用户的公共数据视图，是数据库中全部数据的逻辑结构和特征的描述。 \n        *     •一个数据库只有一个模式。模式不但要描述数据的逻辑结构，还要描述数据之间的联系、数据的完整性、安全性要求。 \n    * 内模式\n        * 又称为存储模式，是数据库物理结构和存储方式的描述，是数据在数据库内部的表示方式。 \n        *     •一个数据库只有一个内模式。内模式并不涉及物理记录，也不涉及硬件设备。\n* •二层映象功能：外模式/模式映象和模式/内模式映象 \n    * 三层模式关系\n        * 数据库模式是数据库的核心和关键，外模式通常是模式的子集。数据按外模式的描述提供给用户，按内模式的描述存储在硬盘上，而模式介于外、内模式之间，既不涉及外部的访问，也不涉及内部的存储，从而起到隔离作用，有利于保持数据的独立性，内模式依赖于全局逻辑结构，但可以独立于具体的存储设备\n    * 映象\n        * 是一种对应规则，说明映象双方如何进行转换。 \n    * 外模式/模式映象\n        * 作用：把描述局部逻辑结构的外模式与描述全局逻辑结构的模式联系趣来\n        * 当模式改变时，只要对外模式/模式映象做相应的改变，使外模式保持不变，则以外模式为依据的应用程序不受影响，从而保证了数据与程序之间的逻辑独立性，也就是数据的逻辑独立性 \n    * 模式/内模式映象\n        * 作用：把描述全局逻辑结构的模式与描述物理结构的内模式联系起来\n        * 当内模式改变时，比如存储设备或存储方式有所改变，只要模式/内模式映象做相应的改变，使模式保持不变，则应用程序就不受影响，从而保证了数据与程序之的物理独立性。\n## 关系模型\n### 关系模型组成的三要素\n* 关系数据结构\n    * 基本概念\n        * 关系\n        * 关系模式\n            * 什么是关系模式\n                * 关系模式（Relation Schema）是型\n            * 关系是值\n                * 关系模式是对关系的描述\n        * 关系数据库\n* 关系操作集合\n* 关系完整性约束\n    * 关系模型的完整性规则是对关系的某种约束条件\n    * 实体完整性和参照完整性是关系模型必须满足的完整性约束条件，被称作是关系的两个不变性，应该由关系系统自动支持。\n### 基本关系的六大性质\n* ① 列是同质的（Homogeneous）\n    * 每一列中的分量是同一类型的数据，来自同一个域\n* ② 不同的列可出自同一个域\n    * 其中的每一列称为一个属性\n    * 不同的属性要给予不同的属性名\n* ③ 列的顺序无所谓\n    * 列的次序可以任意交换\n    * 遵循这一性质的数据库产品(如ORACLE)，增加新属性时，永远是插至最后一列。但也有许多关系数据库产品没有遵循这一性质，例如FoxPro仍然区分了属性顺序\n* ④ 任意两个元组的候选码不能完全相同\n    * 候选码是可以惟一标识一个元组的属性或属性组。若一个关系中的候选码有多个，则选择一个作为主码\n* ⑤ 行的顺序无所谓\n    * 行的次序可以任意交换\n    * 遵循这一性质的数据库产品(如ORACLE)，插入一个元组时永远插至最后一行。但也有许多关系数据库产品没有遵循这一性质，例如FoxPro仍然区分了元组的顺序\n\n* ⑥ 分量必须取原子值\n    * 每一个分量都必须是不可分的数据项。\n### 关系模型中的三类完整性约束\n* 实体完整性\n* 参照完整性\n    * 外码（Foreign Key）\n* 用户定义的完整性\n## 关系代数\n### 概述\n* 关系代数是一种抽象的查询语言，用对关系的运算来表达查询，作为研究关系数据语言的数学工具。\n* 关系代数的运算对象是关系，运算结果亦为关系。 \n### 关系代数的运算\n* 普通的集合运算\n    * 并、交、差\n* 删除部分关系的运算\n    * 选择、投影\n* 合并两个关系元组的运算\n    * 连接、积\n* 改名运算\n### 关系代数\n* 并Union (∪)\n    * R和S的并，R∪S，是在R或S或两者中的元素的集合\n    * 一个元素在并集中只出现一次\n    * R和S必须同类型（属性集相同、次序相同，但属性名可以不同）\n* 交Intersect (∩)\n    * R和S的交，R∩S，是在R和S中都存在的元素的集合\n    * 一个元素在交集中只出现一次\n    * R和S必须同类型（属性集相同、次序相同，但属性名可以不同）\n* 差Minus (-)\n    * R和S的差，R-S，是在R中而不在S中的元素的集合\n    * R和S必须同类型（属性集相同、次序相同，但属性名可以不同）\n* 投影Projection(π)\n    * 从关系R中选择若干属性组成新的关系\n    * πA1,A2,…,An(R),表示从R中选择属性集A1,A2,…,An组成新的关系\n    * 列的运算\n    * 投影运算的结果中,也要去除可能的重复元组\n* 广义笛卡儿积(×)\n    * 关系R、S的广义笛卡儿积是两个关系的元组对的集合所组成的新关系\n    * R×S：\n        * 属性是R和S的组合（有重复）\n        * 元组是R和S所有元组的可能组合\n        * 是R、S的无条件连接，使任意两个关系的信息能组合在一起\n* 选择Selection(σ)\n    * 从关系R中选择符合条件的元组构成新的关系\n    * σC(R),表示从R中选择满足条件(使逻辑表达式C为真)的元组\n    * 行的运算\n* 条件连接(θ)\n    * 从R×S的结果集中，选取在指定的属性集上满足AθB条件的元组，组成新的关系\n    * θ是一个关于属性集的比较运算符\n    * θ为“＝”的连接运算称为等值连接。\n* 自然连接\n    * 从R×S的结果集中，选取在某些公共属性上具有相同值的元组，组成新的关系\n    * R、S的公共属性\n        * 属性集的交集（名称及类型相同）\n    * 公共属性在结果中只出现一次\n    * 等值连接\n* 关系代数—除( ÷ )\n    * 给定关系R(X,Y)和S(Y,Z)，其中X, Y, Z为属性组。R中的Y与S中的Y可以有不同的属性名，但必须出自相同的域集。R与S的除运算得到一个新的关系P(X)，P是R中满足下列条件的元组在X属性列上的投影：元组在X上分量值x的象集Yx包含S在Y上投影的集合。\n    *  R÷S = {tr[X]| tr∈R∧πy       (S)Yx} \n    * 其中Yx为x在R中的象集，x=tr[X]。 \n    * 例子\n## 数据库语言SQL\n### SQL的发展\n* 1974年，由Boyce和Chamberlin提出\n* 1975~1979，IBM San Jose Research Lab的关系数据库管理系统原型System R实施了这种语言\n* SQL-86是第一个SQL标准\n* SQL-89、SQL-92(SQL2)、SQL-99(SQL3)\n### 非过程化语言\n* SQL语言进行数据库操作时，只需要提出“做什么”，不需要指明“怎么做”。“怎么做”是由DBMS来完成\n### SQL的形式\n* 交互式SQL\n    * 一般DBMS都提供联机交互工具\n    * 用户可直接键入SQL命令对数据库进行操作\n    * 由DBMS来进行解释\n* 嵌入式SQL\n    * 能将SQL语句嵌入到高级语言（宿主语言）\n    * 使应用程序充分利用SQL访问数据库的能力、宿主语言的过程处理能力\n    * 一般需要预编译，将嵌入的SQL语句转化为宿主语言编译器能处理的语句\n### SQL语言主要组成部分 \n* 数据定义语言（DDL，Data Definition Language）\n    * 数据定义语言是指用来定义和管理数据库以及数据库中的各种对象的语句，这些语句包括CREATE、ALTER和DROP等语句。在SQL Server中，数据库对象包括表、视图、触发器、存储过程、规则、缺省、用户自定义的数据类型等。这些对象的创建、修改和删除等都可以通过使用CREATE、ALTER、DROP等语句来完成。\n    * 常见的数据类型\n        * 字符型：\n            *      定长字符型 char(n) 由于是定长，所以速度快\n            *      变长字符型 varchar(n)   \n        * 数值型：\n            *      整型 int(或integer)   -231~+231\n            * 短整型 smallint -215~+215的\n            *      浮点型 real、float、double\n            *      数值型 numeric (p [,d])\n        * 日期／时间型：\n            *      DateTime\n        * 文本和图像型\n            *  Text：存放大量文本数据。在SQLServer中，Text对象实际为一指针\n            * Image：存放图形数据\n* 数据操纵语言（DML，Data Manipulation Language）\n    * 数据操纵语言是指用来查询、添加、修改和删除数据库中数据的语句，这些语句包括SELECT、INSERT、UPDATE、DELETE等。在默认情况下，只有sysadmin、dbcreator、db_owner或db_datawriter等角色的成员才有权利执行数据操纵语言。\n* 数据控制语言（DCL，Data Control Language）\n    * 数据控制语言（DCL）是用来设置或者更改数据库用户或角色权限的语句，这些语句包括GRANT、REVOKE 、DENY等语句，在默认状态下，只有sysadmin、dbcreator、db_owner或db_securityadmin等角色的成员才有权利执行数据控制语言。\n### SQL语句\n* 建立表结构 Create\n    * 定义基本表的语句格式：\n    * CREATE TABLE <表名>(<列定义>[{,<列定义>,<表约束>}])\n    * 表名：\n    * 列定义：列名、列数据类型、长度、是否允许空值等。\n    * 定义完整性约束：列约束和表约束\n    * [CONSTRAINT<约束名>] <约束定义>\n* 删除表结构 Drop\n    * 用SQL删除关系（表）\n        * 将整个关系模式（表结构）彻底删除\n        * 表中的数据也将被删除\n* 修改表结构 Alter\n    * 增加表中的属性\n        * 向已经存在的表中添加属性\n        * allow null （新添加的属性要允许为空）\n        * 已有的元组中该属性的值被置为Null\n    * 修改表中的某属性(某列)\n        * 修改属性类型或精度\n    * 删除表中的某属性(某列)\n        * 去除属性及相应的数据\n* 向表中添加数据(Insert)\n    * 数据添加\n        * 用SQL的插入语句，向数据库表中添加数据\n        * 按关系模式的属性顺序\n        * 按指定的属性顺序，也可以只添加部分属性（非Null属性为必需）\n* 数据删除（Delete）\n    * 只能对整个元组操作，不能只删除某些属性上的值\n    * 只能对一个关系起作用，若要从多个关系中删除元组，则必须对每个关系分别执行删除命令\n    * 删除单个元组\n    * 删除多个元组\n    * 删除整个关系中的所有数据\n* 数据更新（Update）\n    * 改变符合条件的某个（某些）元组的属性值\n* 数据查询（Select）\n    * 数据查询是数据库应用的核心功能\n    * Select子句——重复元组\n        * SQL具有包的特性\n        * Select 子句的缺省情况是保留重复元组（ ALL ），可用 Distinct 去除重复元组\n        * 去除重复元组:费时\n        * 需要临时表的支持\n    * Select子句—— *与属性列表\n        * 星号 * 表示所有属性\n            * 星号 * ：按关系模式中属性的顺序排列\n            * 显式列出属性名：按用户顺序排列\n    * Select子句——更名\n        * 为结果集中的某个属性改名\n        * 使结果集更具可读性\n    * Where 子句\n        * 查询满足指定条件的元组可以通过Where子句来实现\n        * 使where子句中的逻辑表达式返回True值的元组，是符合要求的元组，将被选择出来\n        * Where 子句——运算符\n            * 比较：<、<=、>、>=、=、<> 等\n            * 确定范围：\n                * Between  A  and  B、Not Between A and B\n            * 确定集合：IN、NOT IN\n            * 字符匹配：LIKE，NOT LIKE\n            * 空值：IS NULL、IS NOT NULL\n            * 多重条件：AND、OR、NOT\n        * Where 子句——Like\n            * 字符匹配：Like、Not Like\n            * 通配符\n            * % —— 匹配任意字符串\n            * _   —— 匹配任意一个字符\n            * 大小写敏感\n        * Where 子句——转义符 escape \n    * From 子句\n        * 列出将被查询的关系（表）\n        * From 子句——元组变量\n            * 为 From 子句中的关系定义元组变量\n            * 方便关系名的引用\n        * 连接子句\n            * 内连接\n                * 内连接是指包括符合条件的每个表的记录，也称之为全记录操作。\n            * 外连接\n                * 外连接是指把两个表分为左右两个表。右外连接是指连接满足条件右侧表的全部记录。左外连接是指连接满足条件左侧表的全部记录。全外连接是指连接满足条件表的全部记录。\n                * 左外连接\n                * 右外连接\n                * 全外连接\n    * Order By子句\n        * 指定结果集中元组的排列次序\n        * 耗时\n        * ASC升序（缺省）、DESC降序\n    * 子查询（Subquery ）\n        * 子查询是嵌套在另一查询中的 Select-From-Where 表达式（Where/Having）\n        * SQL允许多层嵌套，由内而外地进行分析，子查询的结果作为父查询的查找条件\n        * 可以用多个简单查询来构成复杂查询，以增强SQL的查询能力\n        * 子查询中不使用 Order By 子句，Order By子句只能对最终查询结果进行排序\n        * 子查询——单值比较\n            * 返回单值的子查询，只返回一行一列\n            * 父查询与单值子查询之间用比较运算符进行连接\n                * 运算符：>、>=、=、<=、<、 <>\n        * 子查询——多值\n            * 子查询返回多行一列\n            * 运算符：In、All、Some(或Any)、Exists\n                * 子查询——多值成员In\n                    * 若值与子查询返回集中的某一个相等，则返回true\n                        *  IN 被用来测试多值中的成员\n                * 子查询——多值比较 ALL\n                    * 父查询与多值子查询之间的比较用All来连接\n                    * 值s比子查询返回集R中的每个都大时，s>All R 为True \n                    * All表示所有\n                    * > all、< all、<=all、>=all、<> all\n                    * <> all 等价于 not in\n                * 子查询——多值比较Some/Any\n                    * 父查询与多值子查询之间的比较需用Some/Any来连接\n                    * 值s比子查询返回集R中的某一个都大时返回 Ture\n                        * s > Some R为True  或 \n                        * s > Any R为True \n                    * Some(早期用Any)表示某一个（任意一个）\n                    *  > some、< some、<=some、>=some、<> some\n                    * = some 等价于 in、<> some 不等价于 not in\n        * 子查询——存在判断Exists\n            * Exists + 子查询用来判断该子查询是否返回元组\n            * 当子查询的结果集非空时，Exists为True\n            * 当子查询的结果集为空时，Exists为False\n            * 不关心子查询的具体内容，因此用 Select *\n            * 具有外部引用的子查询，称为相关子查询（Correlated Queries）\n            * 外层元组的属性作为内层子查询的条件\n    * 聚合函数\n        * 把一列中的值进行聚合运算，返回单值的函数\n        * 五个预定义的聚合函数\n            * 平均值：Avg( )\n            * 总和：  Sum( )\n            * 最小值：Min( )\n            * 最大值：Max( )\n            * 计数：  Count( )  返回所选列中不为NULL的数\n        * Group By\n            * 将查询结果集按某一列或多列的值分组，值相等的为一组，一个分组以一个元组的形式出现\n            * 只有出现在Group By子句中的属性，才可出现在Select子句中\n        * Having\n            * 针对聚合函数的结果值进行筛选（选择），它作用于分组计算结果集\n            * 跟在Group By子句的后面。\n        * Having 与 Where的区别\n            * Where 决定哪些元组被选择参加运算，作用于关系中的元组\n            * Having 决定哪些分组符合要求，作用于分组\n            * 聚合函数的条件关系必须用Having，Where中不应出现聚合函数\n        * 聚合函数对Null的处理\n            * Count：不计\n            * Sum：不将其计入\n            * Avg：具有 Null 的元组不参与\n            * Max / Min：不参与\n### 视     图   (VIEW)\n* 视图是从一个或者多个表或视图中导出的表，其结构和数据是建立在对表的查询基础上的。和真实的表一样，视图也包括几个被定义的数据列和多个数据行，但从本质上讲，这些数据列和数据行来源于其所引用的表。因此，视图不是真实存在的基础表而是一个虚拟表，视图所对应的数据并不实际地以视图结构存储在数据库中，而是存储在视图所引用的表中。\n* 创建视图\n* 视图的更新\n### 索引\n* 数据库中的索引与书籍中的索引类似，在一本书中，利用索引可以快速查找所需信息，无须阅读整本书。在数据库中，索引使数据库程序无须对整个表进行扫描，就可以在其中找到所需数据。书中的索引是一个词语列表，其中注明了包含各个词的页码。而数据库中的索引是某个表中一列或者若干列值的集合和相应的指向表中物理标识这些值的数据页的逻辑指针清单\n* 索引的作用\n    * 通过创建唯一索引，可以保证数据记录的唯一性。\n    * 可以大大加快数据检索速度。\n    * 可以加速表与表之间的连接，这一点在实现数据的参照完整性方面有特别的意义。\n    * 在使用ORDER BY和GROUP BY子句中进行检索数据时，可以显著减少查询中分组和排序的时间。\n    * 使用索引可以在检索数据的过程中使用优化隐藏器，提高系统性能\n* 聚集索引与非聚集索引\n    * 聚集索引对表的物理数据页中的数据按列进行排序，然后再重新存储到磁盘上，即聚集索引与数据是混为一体的，它的叶节点中存储的是实际的数据\n    * 非聚集索引具有完全独立于数据行的结构，使用非聚集索引不用将物理数据页中的数据按列排序。非聚集索引的叶节点存储了组成非聚集索引的关键字值和行定位器\n* 创建索引\n### 约束\n* 主键约束（primary key constraint）\n* 唯一性约束（unique constraint）\n* 检查约束（check constraint）\n* 缺省约束（default constraint）\n* 外部键约束（foreign key constraint）\n### SQL SERVER权限管理\n* SQL Server权限管理策略 \n    * 安全帐户认证 \n        * 安全帐户认证是用来确认登录SQL Server的用户的登录帐号和密码的正确性，由此来验证其是否具有连接SQL Server的权限。 SQL Server 2000提供了两种确认用户的认证模式：\n            * （一）Windows NT认证模式。\n                * SQL Server数据库系统通常运行在Windows NT服务器平台上，而NT作为网络操作系统，本身就具备管理登录、验证用户合法性的能力，因此Windows NT认证模式正是利用了这一用户安全性和帐号管理的机制，允许SQL Server也可以使用NT的用户名和口令。在这种模式下，用户只需要通过Windows NT的认证，就可以连接到SQL Server，而SQL Server本身也就不需要管理一套登录数据。\n            * （二）混合认证模式。\n                * 混合认证模式允许用户使用Windows NT安全性或SQL Server安全性连接到SQL Server，这就意味着用户可以使用他的帐号登录到Windows NT，或者使用他的登录名登录到SQL Server系统。NT的用户既可以使用NT认证，也可以使用SQL Server认证\n    * 访问许可确认 \n        * 但是通过认证阶段并不代表用户能够访问SQL Server中的数据，同时他还必须通过许可确认。用户只有在具有访问数据库的权限之后，才能够对服务器上的数据库进行权限许可下的各种操作，这种用户访问数据库权限的设置是通过用户帐号来实现的。\n* 用户权限管理\n    * 服务器登录帐号和用户帐号管理 \n        * 1.利用企业管理器创建、管理SQL Server登录帐号\n            * （１）打开企业管理器，单击需要登录的服务器左边的“+”号，然后展开安全性文件夹。 \n            * （２）用右键单击登录（login）图标，从快捷菜单中选择新建登录（new login）选项，则出现SQL Server登录属性—新建登录对话框，如图6-2所示。\n            * （3）在名称编辑框中输入登录名，在身份验证选项栏中选择新建的用户帐号是Windows NT认证模式，还是SQL Server认证模式。 \n            * （４）选择服务器角色页框。在服务器角色列表框中，列出了系统的固定服务器角色。 \n            * （５）选择用户映射页框。上面的列表框列出了该帐号可以访问的数据库，单击数据库左边的复选框，表示该用户可以访问相应的数据库以及该帐号在数据库中的用户名。 \n            * （６）设置完成后，单击“确定”按钮即可完成登录帐号的创建。 \n        * 使用SQL 语句创建登录帐号\n        * 2.用户帐号管理 \n            * 在数据库中，一个用户或工作组取得合法的登录帐号，只表明该帐号通过了Windows NT认证或者SQL Server认证，但不能表明其可以对数据库数据和数据库对象进行某种或者某些操作，只有当他同时拥有了用户权限后，才能够访问数据库。 \n            * 利用企业管理器可以授予SQL Server登录访问数据库的许可权限。使用它可创建一个新数据库用户帐号 \n    * 许可（权限）管理 \n        * 许可用来指定授权用户可以使用的数据库对象和这些授权用户可以对这些数据库对象执行的操作。用户在登录到SQL Server之后，其用户帐号所归属的NT组或角色所被赋予的许可（权限）决定了该用户能够对哪些数据库对象执行哪种操作以及能够访问、修改哪些数据。在每个数据库中用户的许可独立于用户帐号和用户在数据库中的角色，每个数据库都有自己独立的许可系统，在SQL Server中包括三种类型的许可：即对象许可、语句许可和预定义许可。 \n            * 三种许可类型\n                * 1、对象许可\n                    * 表示对特定的数据库对象，即表、视图、字段和存储过程的操作许可，它决定了能对表、视图等数据库对象执行哪些操作。\n                * 2、语句许可\n                    * 表示对数据库的操作许可，也就是说，创建数据库或者创建数据库中的其它内容所需要的许可类型称为语句许可。\n                * 3、预定义许可\n                    * 是指系统安装以后有些用户和角色不必授权就有的许可。 \n    * 角色管理\n        * 角色是SQL Server 7.0版本引进的新概念，它代替了以前版本中组的概念。利用角色，SQL Server管理者可以将某些用户设置为某一角色，这样只对角色进行权限设置便可以实现对所有用户权限的设置，大大减少了管理员的工作量。SQL Server提供了用户通常管理工作的预定义服务器角色和数据库角色。\n            * 1、服务器角色\n                * 服务器角色是指根据SQL Server的管理任务，以及这些任务相对的重要性等级来把具有SQL Server管理职能的用户划分为不同的用户组，每一组所具有的管理SQL Server的权限都是SQL Server内置的，即不能对其进行添加、修改和删除，只能向其中加入用户或者其他角色。 \n                * 几种常用的固定服务器角色 \n                    * 系统管理员：拥有SQL Server所有的权限许可。\n                    * 服务器管理员：管理SQL Server服务器端的设置。\n                    * 磁盘管理员：管理磁盘文件。\n                    * 进程管理员：管理SQL Server系统进程。\n                    * 安全管理员：管理和审核SQL Server系统登录。\n                    * 安装管理员：增加、删除连接服务器，建立数据库复制以及管理扩展存储过程。\n                    * 数据库创建者：创建数据库，并对数据库进行修改。\n            * 2、数据库角色 \n                * 数据库角色是为某一用户或某一组用户授予不同级别的管理或访问数据库以及数据库对象的权限，这些权限是数据库专有的，并且还可以使一个用户具有属于同一数据库的多个角色。SQL Server提供了两种类型的数据库角色：即固定的数据库角色和用户自定义的数据库角色。 \n                * （１）固定的数据库角色\n                    * public：维护全部默认许可。\n                    * db_owner：数据库的所有者，可以对所拥有的数据库执行任何操作。\n                    * db_accessadmin：可以增加或者删除数据库用户、工作组和角色。\n                    * db_addladmin：可以增加、删除和修改数据库中的任何对象。\n                    * db_securityadmin：执行语句许可和对象许可。\n                    * db_backupoperator：可以备份和恢复数据库。\n                    * db_datareader：能且仅能对数据库中的任何表执行select操作，从而读取所有表的信息。\n                    * db_datawriter：能够增加、修改和删除表中的数据，但不能进行select操作。\n                    * db_denydatareader：不能读取数据库中任何表中的数据。\n                    * db_denydatawriter：不能对数据库中的任何表执行增加、修改和删除数据操作。 \n                * （２）用户自定义角色 \n                    * 创建用户定义的数据库角色就是创建一组用户，这些用户具有相同的一组许可。如果一组用户需要执行在SQL Server中指定的一组操作并且不存在对应的Windows NT组，或者没有管理Windows NT用户帐号的许可，就可以在数据库中建立一个用户自定义的数据库角色。用户自定义的数据库角色有两种类型：即标准角色和应用程序角色。\n* Transaction_SQL 语句\n    * 赋权语句——Grant\n    * 收回权限——Revoke \n    * 收回权限——Deny \n## 查询优化\n### 概述\n* 关系系统和关系模型是两个密切相关而有不同的概念。支持关系模型的数据库管理系统称为关系系统。但是关系模型中并非每一部分都是同等重要的，所以我们不苛求完全支持关系模型的系统才能称为关系系统。因此，我们给出一个关系系统的最小要求以及分类的定义。 \n* 关系系统的定义\n    * 1.支持关系数据库（关系数据结构）\n        *       从用户观点看，数据库由表构成，并且只有表这一种结构。\n    * 2.支持选择、投影和（自然）连接运算，对这些运算不必要求定义任何物理存取路径 \n        *        当然并不要求关系系统的选择、投影、连接运算和关系代数的相应运算完全一样，而只要求有等价的这三种运算功能就行。 \n### 查询优化\n* 查询优化：对于给定的查询选择代价最小的操作序列，使查询过程既省时间，具有较高的效率，这就是所谓的查询优化。对于关系数据库系统，用户只要提出“做什么”，而由系统解决“怎么做”的问题。具体来说，是数据库管理系统中的查询处理程序自动实现查询优化。\n* 关系查询优化是影响RDBMS性能的关键因素。关系系统的查询优化既是RDBMS实现的关键技术又是关系系统的优点所在。\n* 查询优化的优点不仅在于用户不必考虑如何最好地表达查询以获得较好的效率，而且在于系统可以比用户程序的“优化”做得更好。 \n* 查询优化的一般准则\n    * 1.选择运算应尽可能先做。在优化策略中这是最重要、最基本的一条。它常常可使执行时节约几个数量级，因为选择运算一般使计算的中间结果大大变小\n    * 2.在执行连接前对关系适当地预处理。预处理方法主要有两种，在连接属性上建立索引和对关系排序 。\n    * 3.把投影运算和选择运算同时进行。如有若干投影和选择运算，并且它们都对同一个关系操作，则可以在扫描此关系的同时完成所有的这些运算以避免重复扫描关系。 \n    * 4.把投影同其前或其后的双目运算结合起来，没有必要为了去掉某些字段而扫描一遍关系\n    * 5.杷某些选择同在它前面要执行的笛卡尔积结合起来成为一个连接运算，连接特别是等值连接运算要比同样关系上的笛卡尔积省很多时间 \n    * 6.找出公共子表达式。\n## 关系数据库设计理论\n### 设计一个好的关系数据库系统，关键是要设计一个好的数据库模式（数据库逻辑设计问题）\n### 数据库逻辑设计主要解决的问题\n* 关系数据库应该组织成几个关系模式\n* 关系模式中包括哪些属性\n### “不好”的数据库设计\n* 举例：为学校设计一个关系数据库\n* 关系模式: UN(Sno,Cno,G,Sdept,MN)\n    * Sno:描述学生\n    *         Sdept:描述系名\n    *         MN:描述系主任\n    *         Cno:描述课程\n    *         G:描述学习成绩\n    * 根据对现实世界的分析,可得出:Sno,Cno是码\n    * 按照关系模式UN装入部分数据\n*  \n* 对数据库操作时,会出现以下问题\n    * 1. 数据冗余(系主任名的存储次数)\n        *    数据重复存储:浪费存储空间,数据库维护困难(更新异常)\n    * 2. 插入异常(一个系刚成立)\n        *    主码为空的记录不能存在与数据库,导致不能进行插入操作\n    * 3. 删除异常(一个系的学生全部毕业)\n        *     删除操作后,一些相关信息无法保存在数据库中\n* 要消除以上的“弊病”,把上面的关系数据库模式分解为三个关系模式\n    * S(Sno,Sdept)\n    *     SG(Sno,Cno,G)\n    *     Dept(Sdept,MN)\n### 函数依赖\n* 类似于变量之间的单值函数关系\n*      Y=F(X),其中自变量X的值,决定一个唯一的函数值Y\n* 在一个关系模式里的属性,由于它在不同元组里属性值可能不同,由此可以把关系中的属性看作变量\n* 一个属性与另一个属性在取值上可能存在制约关系\n* 函数依赖就是属性间的逻辑依赖关系\n* 定义1 设R(U)是一个关系模式,U是R的属性集合,X和Y是U的子集.对于R(U)的任何一个可能的关系r,如果r中不存在两个元组,它们在X上的属性值相同,而在Y上的属性值不同,则称X函数决定Y,或Y函数依赖于X,记作:X  Y.\n* X通常称为“决定因素”\n* 几点说明\n    * 1. 函数依赖是语义范畴的概念.它反映了一种语义完整性约束,只能根据语义来确定一个函数依赖.\n    * 2. 函数依赖是指关系R模式的所有关系元组均应满足的约束条件,而不是关系模式中的某个或某些元组满足的约束条件\n    * 3. 函数依赖与属性间的联系类型有关\n        * (1)若属性X和Y之间有“一对一”的联系,\n        * (2)若属性X和Y之间有“多对一”的联系,\n        * (3)若属性X和Y之间有“多对多”的联系,\n    * 4. 如果X   Y,并且Y不是X的子集,则称X   Y是非平凡的函数依赖;如果Y是X的子集,则称X   Y是平凡的函数依赖;\n### 完全函数依赖与部分函数依赖\n* 完全函数依赖\n* 部分函数依赖\n### 码的形式定义\n* 候选码的两个性质\n    * 1. 标识的唯一性: 对于R(U)中的每一元组,K的值确定后,该元组就相应确定了.\n    * 2. 无冗余性: K是属性组的情况下,K的任何一部分都不能唯一标识该元组(定义中的完全函数依赖的意义) \n### 规范化\n* 简介\n    * 用几个简单的关系去取代原来结构复杂的关系的过程叫做关系规范化.\n    * 规范化理论是研究如何把一个不好的关系模式转化为好的关系模式的理论\n    * 规范化理论是E.E.Codd在1971年首先提出的\n    * 规范化理论是数据库设计过程中的一个非常有用的辅助工具\n* 范式\n    * 简介\n        * 规范化理论是围绕着范式建立的.\n        * 满足不同程度要求的约束集则称为不同的范式.\n        * 如果一个关系满足某个指定的约束集,则称它属于某个特定的范式.\n        * 较高层次的范式比较低层次的范式具有“更合乎要求的性质”\n        * 一个低一级范式的关系模式,通过投影运算可以转化为若干个高一级范式的关系模式的集合,这个过程叫做规范化.\n        * 如果一个关系满足某个范式要求,则它也会满足较其级别低的所有范式的要求\n    * 范式层次\n    * 第一范式(1NF)\n        * 定义5: 在关系模式R中的每一个具体关系r中,如果每个属性值都是不可再分的最小数据单位,则称R是第一范式的关系,记作R∈1NF.\n        * 数据库理论研究的是规范化关系.\n        * 1NF规范化: 把非规范化关系规范提高到1NF关系模式的集合.\n    * 第二范式(2NF)\n        * 定义6: 若关系模式R∈1NF,且每个非主属性都完全依赖于R的任意候选码,则关系模式R属于第二范式,记作R ∈2NF.\n        * 2NF规范化是把1NF关系模式规范提高到变成2NF关系模式的集合.\n        * 从1NF中消除非主属性对候选码的部分函数依赖,则获得2NF关系.\n        * 举例:UN(Sno,Cno,G,SDN,MN)\n    * 第三范式(3NF)\n        * 定义7: 若关系模式R∈2NF,且每个非主属性都不传递依赖于R的任意候选码,则R∈3NF.\n        * 从2NF关系中,消除非主属性对码的传递依赖函数而获得3NF关系\n        * R∈3NF,则每个非主属性既不部分依赖,也不传递依赖于R的任何候选码.\n        * 3NF的规范化\n    * BCNF范式\n        * 3NF的不完善性\n            * 定义8: 若R∈1NF,且R中每个决定因素都是候选码,则R ∈BCNF.\n            * 满足BCNF的关系将消除任何属性对候选码的部分依赖与传递依赖\n            * 应用BCNF定义时,可直接判断1NF是否属于BCNF\n            * BCNF规范化\n## 数据库设计\n### 概述\n* 数据库技术是信息资源管理最有效的手段。数据库设计是指对于一个给定的应用环境，构造最优的数据库模式，建立数据库极其应用系统，有效存储数据，满足用户信息要求和处理要求。 \n### 数据库设计的步骤\n* ⒈需求分析阶段 \n    * 收集和分析用户需求，结果得到数据字典描述的数据需求。 \n    * 常用的调查方法\n        * ⑴跟班作业 \n        * ⑵开调查会\n        * ⑶请专人介绍\n        * ⑷询问对某些调查中的问题，可以找专人询问。\n        * ⑸设计调查表请用户填写\n        * ⑹查阅记录\n* ⒉概念结构设计阶段\n    * 通过对用户需求进行综合、归纳与抽象，形成一个独立于具体DBMS的概念模型，可以用E-R图表示。这是数据库设计的关键\n* ⒊逻辑结构设计阶段\n    * 将概念结构转换为某个DBMS所支持的数据模型（例如关系模型），并对其进行优化（例如使用范式理论）\n* ⒋数据库物理设计阶段\n    * 为逻辑数据模型选取一个最适合应用环境的物理结构（包括存储结构和存取方法）。\n* ⒌数据库实施阶段\n    * 运用DBMS提供的数据语言（例如SQL）及其宿主语言（例如C），根据逻辑设计和物理设计的结果建立数据库，编制与调试应用程序，组织数据入库，并进行试运行\n* ⒍数据库运行和维护阶段\n    * 数据库应用系统经过试运行后即可投入正式运行。在数据库系统运行过程中必须不断地对其进行评价、调整与修改\n### 数据字典\n* 对数据库设计来讲，数据字典是进行数据收集和数据分析所获得的主要成果。数据字典是各类数据描述的集合。 \n* 数据字典通常包括数据项、数据结构、数据流、数据存储和处理过程五个部分。 \n    * 数据项是不可再分的数据单位\n    * 数据结构反映了数据之间的组合关系。一个数据结构可以由若干个数据项组成，也可以由若干个数据结构组成，或由若干个数据项和数据结构混合组成\n    * 数据流是数据结构在系统内传输的路径\n    * 数据存储是数据结构停留或保存的地方，也是数据流的来源和去向之一\n    * 处理过程描述＝｛处理过程名，说明，输入:｛数据流｝，输出:｛数据流｝, 处理:｛简要说明｝｝\n### 设计概念结构通常有四类方法\n* 自顶向下\n    *  即首先定义全局概念结构的框架，然后逐步细化。\n* 自底向上 \n    *  即首先定义各局部应用的概念结构，然后将它们集成起来，得到全局概念结构。这是最经常采用的策略。即自顶向下地进行需求分析，然后再自底向上地设计概念结构\n* 逐步扩张 \n    * 首先定义最重要的核心概念结构，然后向外扩充，以滚雪球的方式逐步生成其他概念结构，直至总体概念结构\n* 混合策略\n    * 即将自顶向下和自底向上相结合，用自顶向下策略设计一个全局概念结构的框架，以它为骨架集成由自底向上策略中设计的各局部概念结构\n### E-R图\n* E-R方法是抽象和描述现实世界的有力工具\n* 要点\n    * 使用长方形来表示实体型，框内写上实体名\n    * 椭圆型表示实体的属性，并用无向边把实体和属性连接起来。\n    * 用菱形表示实体间的联系，菱形框内写上联系名，用无向边把菱形分别与有关实体相连接，在无向边旁标上联系的类型，若实体之间联系也具有属性，则把属性和菱形也用无向边连接上。\n* E-R图之间的冲突主要有三类\n    * 属性冲突 \n        * (1) 属性域冲突，即属性值的类型、取值范围或取值集合不同。 \n        * (2) 属性取值单位冲突\n    * 命名冲突\n        * (1) 同名异义\n        * (2) 异名同义（一义多名）\n    * 结构冲突 \n        * (1) 同一对象在不同应用中具有不同的抽象。例如“教材”在某一局部应用中被当作实体，而在另一局部应用中则被当作属性\n        * (2) 同一实体在不同局部视图中所包含的属性不完全相同，或者属性的排列次序不完全相同\n        * (3) 实体之间的联系在不同局部视图中呈现不同的类型。例如实体E1与E2在局部应用A中是多对多联系，而在局部应用B中是一对多联系；又如在局部应用X中E1与E2发生联系，而在局部应用Y中E1、E2、E3三者之间有联系\n### 逻辑结构设计阶段\n* ⒈一个实体型转换为一个关系模式。实体的属性就是关系的属性。实体的码就是关系的码。\n* ⒉一个m:n联系转换为一个关系模式。与该联系相连的各实体的码以及联系本身的属性均转换为关系的属性。而关系的码为各实体码的组合。\n* ⒊一个1:n联系可以转换为一个独立的关系模式，也可以与n端对应的关系模式合并。如果转换为一个独立的关系模式，则与该联系相连的各实体的码以及联系本身的属性均转换为关系的属性，而关系的码为n端实体的码。\n* ⒋一个1:1联系可以转换为一个独立的关系模式，也可以与任意一端对应的关系模式合并。如果转换为一个独立的关系模式，则与该联系相连的各实体的码以及联系本身的属性均转换为关系的属性，每个实体的码均是该关系的候选码。如果与某一端对应的关系模式合并，则需要在该关系模式的属性中加入另一个关系模式的码和联系本身的属性。\n* ⒌三个或三个以上实体间的一个多元联系转换为一个关系模式。与该多元联系相连的各实体的码以及联系本身的属性均转换为关系的属性。而关系的码为各实体码的组合。\n* 6. 具有相同码的关系模式可合并。\n### 数据模型的优化 \n* 确定数据依赖\n* 对于各个关系模式之间的数据依赖进行极小化处理，消除冗余的联系。\n* 按照数据依赖的理论对关系模式逐一进行分析，考查是否存在部分函数依赖、传递函数依赖、多值依赖等，确定各关系模式分别属于第几范式。\n* 按照需求分析阶段得到的各种应用对数据处理的要求，分析对于这样的应用环境这些模式是否合适，确定是否要对它们进行合并或分解。 \n* 对关系模式进行必要的分解。\n### 设计用户子模式\n* (1) 使用更符合用户习惯的别名 \n* (2) 针对不同级别的用户定义不同的视图，以满足系统对安全性的要求\n* (3) 简化用户对系统的使用\n### 数据库物理设计 \n* 确定数据库存储结构时要综合考虑存取时间、存储空间利用率和维护代价三方面的因素。这三个方面常常是相互矛盾的。\n* 为了提高系统性能，数据应该根据应用情况将易变部分与稳定部分、经常存取部分和存取频率较低部分分开存放\n## 数据库恢复技术\n### 什么是事务\n* 事务(Transaction)是用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位\n* 事务和程序是两个概念\n    * 在关系数据库中，一个事务可以是一条SQL语句，一组SQL语句或整个程序\n    * 一个应用程序通常包含多个事务\n* 事务是恢复和并发控制的基本单位\n### 事务结束\n* COMMIT\n    * 事务正常结束   \n    * 提交事务的所有操作（读+更新）\n    * 事务中所有对数据库的更新永久生效\n* ROLLBACK\n    * 事务异常终止\n        * 事务运行的过程中发生了故障，不能继续执行\n        * 回滚事务的所有更新操作\n        * 事务滚回到开始时的状态\n### 事务的特性(ACID特性)\n* 原子性（Atomicity）\n    * 事务是数据库的逻辑工作单位\n    * 事务中包括的诸操作要么都做，要么都不做\n* 一致性（Consistency）\n    * 事务执行的结果必须是使数据库从一个   一致性状态变到另一个一致性状态\n    * 一致性状态：\n        * 数据库中只包含成功事务提交的结果\n    * 不一致状态：\n        * 数据库中包含失败事务的结果\n* 隔离性（Isolation）\n    * 对并发执行而言一个事务的执行不能被其他事务干扰\n\n    * 一个事务内部的操作及使用的数据对其他并发事务是隔离的\n    * 并发执行的各个事务之间不能互相干扰\n* 持续性（Durability ）\n    * 持续性也称永久性（Permanence）\n    * 一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。\n    * 接下来的其他操作或故障不应该对其执行结果有任何影响。\n### 故障\n* 故障原因\n    * 计算机硬件故障\n    * 系统软件和应用软件的错误\n    * 操作员的失误\n    * 恶意的破坏\n* 故障的影响\n    * 运行事务非正常中断\n    * 破坏数据库\n* 故障的种类\n    * 事务故障\n    * 系统故障\n    * 介质故障\n    * 计算机病毒\n### 恢复操作的基本原理\n* 恢复操作的基本原理：冗余\n* 利用存储在系统其它地方的冗余数据来重建数据库中已被破坏或不正确的那部分数据\n### 恢复的实现技术\n* 数据转储（backup）\n* 登录日志文件（logging）\n## 并发控制\n### 多事务执行方式\n* (1)事务串行执行\n    * 每个时刻只有一个事务运行，其他事务必须等到这个事务结束以后方能运行\n    * 不能充分利用系统资源，发挥数据库共享资源的特点\n* (2)交叉并发方式（interleaved concurrency）\n    * 事务的并行执行是这些并行事务的并行操作轮流交叉运行\n    * 是单处理机系统中的并发方式，能够减少处理机的空闲时间，提高系统的效率\n* (3)同时并发方式（simultaneous  concurrency）\n    * 多处理机系统中，每个处理机可以运行一个事务，多个处理机可以同时运行多个事务，实现多个事务真正的并行运行\n    * 最理想的并发方式，但受制于硬件环境\n    * 更复杂的并发方式机制\n### 事务并发执行带来的问题\n* 可能会存取和存储不正确的数据，破坏事务的隔离性和数据库的一致性\n* DBMS必须提供并发控制机制\n* 并发控制机制是衡量一个DBMS性能的重要标志之一\n### 并发控制机制的任务\n* 对并发操作进行正确调度\n* 保证事务的隔离性\n* 保证数据库的一致性\n### 并发操作带来的数据不一致性\n* 丢失修改（lost update）\n    * 丢失修改是指事务1与事务2从数据库中读入同一数据并修改\n    * 事务2的提交结果破坏了事务1提交的结果，导致事务1的修改被丢失。\n* 不可重复读（non-repeatable read）\n    * 不可重复读是指事务1读取数据后，事务2执行更新操作，使事务1无法再现前一次读取结果。\n* 读“脏”数据（dirty read）\n    * 事务1修改某一数据，并将其写回磁盘\n    * 事务2读取同一数据后\n    * 事务1由于某种原因被撤消，这时事务1已修改过的数据恢复原值\n    * 事务2读到的数据就与数据库中的数据不一致，\n    * 是不正确的数据，又称为“脏”数据。\n### 封锁\n* 什么是封锁\n    * 封锁就是事务T在对某个数据对象（例如表、记录等）操作之前，先向系统发出请求，对其加锁\n    * 加锁后事务T就对该数据对象有了一定的控制，在事务T释放它的锁之前，其它的事务不能更新此数据对象。\n    * 封锁是实现并发控制的一个非常重要的技术\n* 基本封锁类型\n    * 排它锁（eXclusive lock，简记为X锁）\n        * 排它锁又称为写锁\n        * 若事务T对数据对象A加上X锁，则只允许T读取和修改A，其它任何事务都不能再对A加任何类型的锁，直到T释放A上的锁\n    * 共享锁（Share lock，简记为S锁）\n        * 共享锁又称为读锁\n        * 若事务T对数据对象A加上S锁，则其它事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁\n* 基本锁的相容矩阵\n* 封锁协议\n    * 1级封锁协议\n        * 事务T在修改数据R之前必须先对其加X锁，直到事务结束才释放\n        * 1级封锁协议可防止丢失修改\n        * 在1级封锁协议中，如果是读数据，不需要加锁的，所以它不能保证可重复读和不读“脏”数据。\n            * 读“脏”数据\n            * 不可重复读\n    * 2级封锁协议\n        * 1级封锁协议+事务T在读取数据R前必须先加S锁，读完后即可释放S锁\n        * 2级封锁协议可以防止丢失修改和读“脏”数据。\n        * 在2级封锁协议中，由于读完数据后即可释放S锁，所以它不能保证可重复读。\n    * 3级封锁协议\n        * 1级封锁协议 + 事务T在读取数据R之前必须先对其加S锁，直到事务结束才释放\n        * 3级封锁协议可防止丢失修改、读脏数据和不可重复读。\n    * 三级协议的主要区别\n## 完整性约束\n### 完整性约束的分类\n* 静态列级约束\n    * 1. 对数据类型的约束，包括数据的类型、长度单位、精度等\n    * 2. 对数据格式的约束 \n    * 3. 对取值范围或取值集合的约束\n    * 4. 对空值的约束\n    * 5. 其他约束 \n* 静态元组约束\n    * 一个元组是由若干个列值组成的，静态元组约束就是规定元组的各个列之间的约束关系\n* 静态关系约束\n    * 在一个关系的各个元组之间或者若干关系之间常常存在各种联系或约束。 （参照完整性－外码约束）\n* 动态列级约束\n    * 1. 修改列定义时的约束 \n    * 2. 修改列值时的约束\n* 动态元组约束 \n    * 动态元组约束是指修改元组的值时元组中各个字段间需要满足某种约束条件\n* 动态关系约束\n    * 动态关系约束是加在关系变化前后状态上的限制条件，例如事务一致性、原子性等约束条件","tags":["技术探究"],"categories":["技术"]},{"title":"软件体系结构","url":"/2021/01/06/软件体系结构/","content":"\n关键点串联\n\n<!--more-->\n\n## 第一章 软件体系结构概论\n\n1. 软件危机\n   1. 概念：是指在计算机软件的开发和维护过程中所遇到的一系列严重问题\n   2. 表现：\n      1. 软件成本日益增长\n      2. 开发进度难以控制\n      3. 软件质量差\n      4. 软件维护困难\n   3. 原因：\n      1. 用户需求不明确\n      2. 缺乏正确的理论指导\n      3. 软件的规模越来越大\n      4. 软件复杂度越来越高\n   4. 软件工程三要素：方法、工具和过程\n2. 构件与软件重用\n   1. 概念：软件重用是指在两次或多次不同的软件开发过程中重复使用相同或相近软件元素的过程\n   2. 软件元素：程序代码、测试用例、设计文档、设计过程、需求分析文档甚至领域知识\n   3. 构建模型三个主要流派：OMG,CORBA,DCOM\n   4. 构建获取：\n      1. 从现有构建中获得\n      2. 遗留工程\n      3. 从市场上购买\n      4. 开发新的\n   5. 构建分类：关键字分类法，刻面分类法，超文本组织法。\n   6. 构件库五类用户：注册用户，公共用户，构建提交者，一般系统管理员，超级系统管理员\n   7. 构建组装：基于功能、数据、面向对象的组装技术\n   8. 系统构建模型四层次：系统构件层，通用类构件层，业务构件层，表现层\n   9. 组织结构的重用：构件开发组，构件应用组，协调组\n3. 软件体系结构的兴起和发展\n   1. 软件体系结构为软件系统提供了一个结构、行为和属性的高级抽象，由构成系统的元素的描述，这些元素的相互作用，指导元素集成的模型记忆这些模式的约束组成。\n   2. 软件体系结构不仅指定了系统的组织结构和拓扑结构，并且显示了系统需求的构成系统的元素之间的对应关系，提供了一些设计决策的基本原理\n   3. 软件体系结构技术的四个阶段：\n      1. 无体系结构设计阶段\n      2. 萌芽阶段\n      3. 初期阶段\n      4. 高级阶段\n\n## 第二章 软件体系结构建模 ！！\n\n**五种软件体系结构模型：结构模型，框架模型，动态模型，过程模型和功能模型**\n\n1. “4+1”视图模型 ！！\n   1. 逻辑视图：最终用户：功能需求\n   2. 开发视图：编程人员：软件管理\n   3. 进程视图：系统集成人员：性能可扩展性，吞吐量\n   4. 物理视图：系统工程人员：系统拓扑、安装、通信\n   5. 场景视图：场景可以看做那些重要系统活动的抽象，它使4个视图有机联系起来，从某种意义上说场景是最重要的需求抽象。\n2. 软件体系结构的核心模型\n   1. 组成元素：构件、连接件、配置、端口和角色\n3. 软件体系结构的生命周期模型\n   1. 建立软件体系结构阶段\n   2. 软件体系结构的生命周期\n\n## 第三章 软件体系结构风格 ！！\n\n**软件体系结构风格是描述某一特定应用领域中系统组织方式的惯用模式**\n\n**体系结构风格反映了领域中总舵系统所共有的结构和语义特性，并指导如何将各个模块和子系统有效地组织成一个完整的系统。**\n\n1. 经典软件体系结构风格\n   1. 数据流风格\n   2. 调用/返回风格\n   3. 独立构件风格\n   4. 虚拟机风格\n   5. 仓库风格\n   6. 仓库系统及知识库\n2. 客户/服务器风格\n   1. 服务器的主要任务\n   2. 客户端的主要任务\n   3. 服务器负责数据管理，客户机完成与用户的交互任务\n   4. 缺点和优点\n3. 三层C/S风格\n   1. 应该功能分为三个层：表示层，功能层和数据层\n   2. 优点\n4. 浏览/服务器风格\n   1. B/S风格是将三层应用结构的一种实现方式\n   2. 与C/S相比B/S的不足\n5. 异构结构风格\n   1. “内外有别”模型\n   2. “查改有别”模型\n\n## 第四章 软件体系结构描述\n\n1. 软件体系结构描述方法\n   1. 文字表达工具\n   2. 数学表达工具\n   3. 图形表达工具\n2. 体系结构描述语言\n   1. ADL（Architecture Description Language）是这样一种形式化语言，它在底层语义模型的支持下，为软件系统的概念体系结构建模提供了具体的语法和概念框架\n   2. ADL基本元素：构件，连接件，体系结构配置\n   3. ADL能力：构造能力，抽象能力，重用能力，组合能力，异构能力，分析和推理能力\n   4. 构成要素：构件，连接件，体系结构配置\n\n## 第六章 可扩展标记语言\n\n1. XML概述\n   1. 定义：XML是一套定义语义标记的规则，这些标记将文档分成许多部件并对不见加以标识\n   2. 特点：简洁有效，易学易用，开放的国际化标准，高些且可扩充\n2. 解析XML\n   1. 和HTML的区别：XML是元标记语言可以用于定义其他标记语言。XML是“纯”数据。\n   2. XSL是专门用于XML文档的样式单语言\n\n## 第八章 基于服务的体系结构 ！！\n\n1. SOA概述\n   1. SOA(Service-Oriented Architecture)面向服务的体系结构\n   2. SOA是一种在计算环境中设计、开发、部署和管理离散逻辑单元（服务）模型的方法\n   3. 特征：松散耦合，粗颗粒度服务，标准化接口\n2. 面向服务的分析与设计\n   1. 三个抽象级别：操作，服务和业务流程\n3. SOA关键技术 ！！\n   1. 发现服务层\n   2. 描述服务层\n   3. 消息格式层\n   4. 编码格式层\n   5. 传输协议层\n4. SOA的实现方法\n   1. SOA是用本地计算模型来实现一个分布式的计算应用\n   2. Web Service模型中的操作包括发布，查找和绑定，这些操作可以单次或者反复出现。\n5. 服务描述语言\n   1. WSDL(Web Services Description L*anguage*)是对服务进行描述的语言，它有一套基于XML的语法定义\n   2. WSDL子元素：types,message,operation,portType,binding,port,service\n6. 统一描述、发现和集成协议\n   1. UDDI(Universal Description Discovery  and Integration*)是一种用户描述，发现，集成Web服务的技术，他是Web服务协议栈的一个重要部分。\n   2. 数据结构：businessEntity,businessService,bindingTemplate,tModel\n7. 消息封装协议\n   1. SOAP（Simple Object Access Protocol）以XML形式提供一个简单，轻量的用于在分散或分布环境中交换结构化和类型信息的机制\n   2. 主要包括4个部分：SOAP封装结构，SOAP编码规则，SOAP RPC表示，SOAP绑定\n\n## 第九章 富互联网体系结构\n\n1. RIA的概念\n   1. RIA（Rich Internet Application）富互联网应用体系结构\n   2. 富：丰富的数据模型和丰富的用户界面\n\n","tags":["技术探究"],"categories":["技术"]},{"title":"数字图像处理","url":"/2021/01/05/数字图像处理/","content":"\n关键点串联 co-author: @ppy @ysl\n\n<!--more-->\n\n## 第1章 绪论\n\n习题1\n\n1. 解释术语\n   1. 图像 **用各种观测系统以不同形式和手段观测客观世界而获得的、可以直接或间接作用于人的视觉系统而产生的视知觉实体**\n   2. 数字图像 **二维空间和亮度值都是用有限数字数值表示的图像**\n   3. 图像处理 **指对图像信息进行加工，以满足人的视觉或应用需求的行为**\n   4. 数字图像处理 **指利用计算机技术对数值图像进行某些数学运算和各种加工处理，以改善图像的视觉效果和提高图像实用性的技术**\n   5. 图像分析 **通过对图像中不同对象进行分割来对图像中目标进行分类和识别的技术**\n   6. 图像感知与获取 **将景物转换成计算机可以接受的数字图像的过程**\n2. 图像处理的基本特征 **图像处理系统的输入输出都是图像**\n3. 图像分析的基本特征 **图像分析系统的输入是图像，输出是对输入图像进行描述的数据信息**\n4. 图像分析的目的 **缩减对图像的描述，以使其更适合于计算机处理及对不同目标的分类**\n5. 图像处理低级阶段与高级阶段的关系 **低级处理是高一级处理的基础**\n6. 数字图像处理系统由哪几部分组成？各部分的功用是什么？ \n   1. 数字图像源：**提供计算机可以接收的数字图像**\n   2. 计算机系统：**进行对数字图像的处理**\n   3. 图像输出设备：**输出图像处理结果**\n7. 数字图像处理技术研究的基本内容包括哪些 \n   1. **最基本的图像处理方法：主要有图像增强、图像恢复、图像压缩编码、图像分割、图像特征提取、图像的标识与描述、图像变换和图像的基本运算**\n   2. **基于某一特定数学理论的图像处理方法：频率与图像处理方法、小波图像处理方法和形态学图像处理方法**\n8. 请解释研究图像增强的基本思路 **简单地突出图像中感兴趣的特征，或想办法显现图像中那些模糊的细节，以使图像更清晰地被显示或更适合人或机器的处理与分析**\n9. 图像恢复的基本思路 **从退化图像的数学或概率模型出发，研究改进图像的外观，从而使恢复以后的图像尽可能反映原始图像的本来面目**\n10. 图像压缩编码的基本思路 **在不损失图像质量或少损失图像质量的前提下，通过对图像的重新编码，尽可能地减少表示该图像的字节数量，以满足图像存储和实时传输的应用需求**\n11. 图像分割的基本目的 **根据图像的某种特征或某种相似性测度，把一幅图像分成若干个互不交迭且具有相同或相近特征的区域**\n12. 图像的表述和描述的目的 **通过对图像分割等方法得到的图像中感兴趣的区域或目标，寻找出更适合于计算机进一步处理的表示和描述方法**\n13. 简述数字图像处理有哪些应用 **媒体通信、宇宙探索、遥感技术、生物医学、工业生产、气象预报、军事技术、侦缉破案、考古、文化产业**\n14. 简述一个你所熟悉的图像处理的应用实例 **医学上用B超检测仪对人体器官病变的检查和诊断**\n\n## 第2章 数字图像处理基础\n\n2.4 空间分辨率和灰度级分辨率 （分辨率大小的影响\n\n- 空间分辨率是指图像中可分辨的最小细节，由采样间隔值决定。图像空间分辨率越低，图像的视觉效果越差；图像大小不变，图像的分辨率越低，图像阵列$M*N`越小\n- 灰度级分辨率是指在灰度级别中可分辨的最小变化。灰度级分辨率越低，图像的视觉效果越差。\n\n2.5.1 像素的相邻和邻域\n\n- 相邻像素的集合称为邻域\n\n## 第3章 数字图像的基本运算\n\n3.1 灰度反转 \n\n- 对于原图像$f(x,y)$设图像的灰度级为$L$，则图像的灰度反转可表示为$g(x,y) = L-1-f(x,y)$\n\n3.2 对数变换\n\n- 对于原图像$f(x,y)$进行对数变换的解析式可表示为$g(x,y)=c*log(1+f(x,y))$，其中，$c$是一个常数。\n\n- 作用是对原图像的灰度值动态范围进行压缩，主要用于调高输入图像的低灰度值。\n\n  3.3 灰度直方图\n\n- 灰度图像的直方图是一种表示数字图像中各级灰度值及其出现频数的关系的函数，实质上就是柱状图。\n\n- 归一化灰度图像直方图：求该灰度值出现的概率\n\n- 仅能描述图像中每个灰度值具有的像素个数，不能表示图像中每个像素的位置信息\n\n3.4 图像的代数运算\n\n- **图像相加**是通过对两幅大小相同的图像对应位置像素的相加运算，以产生一副新的含有两幅图像信息的图像的方法。$g(x,y) = f_1(x,y)+f_2(x,y)$\n  - 两幅图像相加：$g(x,y) = \\alpha f_1(x,y)+ \\beta f_2(x,y)$\n  - 多幅图像叠加是一种灰度图像的噪声消除方法：$g(x,y) = \\frac{1}{N}f_i(x,y)$\n- **图像相减**：$g(x,y) = f_1(x,y)-f_2(x,y)$ （运算结果要对不符合要求的像素值进行相应的处理）\n\n3.5 图像的几何运算\n\n- 平移\n  - 图像块平移\n  - 整幅图像平移\n- 旋转\n  - 旋转后图像幅面放大\n  - 旋转后图像幅面不变，将图像截断\n- 镜像\n  - 水平镜像\n  - 垂直镜像\n- 转置：将图像显示坐标的$x$轴与$y$轴对换\n- 缩放\n  - 缩小目的：一是为了使缩小后的图像符合显示区域的大小要求；二是为了生成原图像的缩略图\n  - 放大目的：为了使放大后的图像更好地显示在更高分辨率的显示设备上\n\n## 第4章 空间域图像增强 ！！\n\n4.2.1 直方图均衡\n\n- 所谓直方图均衡，就是把一幅已知灰度概率分布的图像，变换成具有均匀概率分布的新图像，通过使其像素灰度值范围和对比度增大，来实现对图像增强的技术和方法。\n- 直方图均衡方法中的直方图是归一化直方图。\n- 实现步骤\n  1. 计算原图像的归一化灰度级别及其分布概率$p_r(r_k)=n_k/n$\n  2. 根据直方图均衡化公式求变换函数的各灰度等级值$s_k$\n  3. 将所得的变换函数的各灰度等级值转化标准的灰度级别值\n  4. 求新图像的各灰度级别值的像素数目\n  5. 求新图像中个灰度级别的分布概率$p_s(s_k)=m_k/n$\n  6. 画出均衡化后的新图像的直方图\n\n4.2.2 直方图规定化\n\n- 把已知直方图的图像变换成具有某种期望的直方图的图像增强方法\n\n4.3 基于空间平滑滤波的图像增强方法\n\n- 模板运算\n\n- 邻域平均法——高斯噪声——非线性平滑滤波图像增强方法——$g(x,y)=\\Biggr\\{\\frac{1}{8}\\displaystyle \\sum^{8}_{i=1}{O_i},当|f(x,y)-\\frac{1}{8}\\displaystyle \\sum^{8}_{i=1}{O_i}|>\\epsilon \\choose f(x,y),其他$\n\n- 中值滤波法——椒盐噪声/脉冲噪声——线性平滑滤波图像增强方法——基本原理是基于某种中值滤波窗口，对该窗口覆盖的所有像素的灰度值进行排序\n\n  1. 根据选定窗口的形状，确定窗口中心位置像素在原图像上的重合方式\n  2. 将窗口在图像上逐像素移动扫描\n  3. 把窗口下对应的像素按它们的灰度值大小进行排序，并找出排序结果的中间的那个值\n\n  - 中值滤波主要优点：运算简单，在滤除噪声的同时能很好地保护信号的细节信息。很容易自适应化，从而进一步提高其滤波特性\n  - 中值滤波的关键在于选择合适的窗口形状和窗口大小；另一个重要因素是排序算法的速度\n\n4.4 基于空间锐化滤波的图像增强方法\n\n- 基于一阶微分的图像增强法\n  1. 利用梯度法检测和突出图像中的边缘\n  2. 基于某一门限阙值，通过利用超过门限的梯度值或某一指定的灰度值代替图像中相应的边缘来形成增强的结果图像\n- 基于二阶微分的图像增强法————拉普拉斯算子锐化方法\n\n## 第5章 频率域图像处理 ！！\n\n- 频率域图像处理是通过傅里叶变换把图像从空间域变换到频率域，然后用频率域方法对图像进行处理，处理完后再利用傅里叶反变换把图像变换回空间域\n\n5.2 频率域图像处理的基本实现思路\n\n$G(u,v) = F(u,v)H(u,v)\\\\\ng(x,y) = F^{-1}[G(u,v)]$\n\n1. 用$(-1)^{(x+y)}$乘以输入图像进行中心变换\n2. 对步骤1的计算结果图像进行二维傅里叶变换，求F(u,v)\n3. 用设计的转移函数H(u,v)乘以F(u,v)，即求G(u,v)  \n4. 求步骤3的计算结果的傅里叶反变换，即计算$F^{-1}[G(u,v)]$\n5. 取步骤4的实部\n6. 用$(-1)^{(x+y)}$乘以步骤5的计算结果，就可以通过频率域增强后的图像g(x,y)\n   5.3 基于频率域的图像噪声消除——频率域低通滤波(**选择能使低频通过，使高频衰减的转移函数实现低通滤波，达到滤除噪声的目的**)\n\n- 理想低通滤波器\n- 巴特沃斯低通滤波器\n- 高斯低通滤波器\n\n5.4 基于频率域的图像增强——频率域高通滤波(**选择能使高频通过，使低频衰减的转移函数实现高通滤波，达到突出图像的高频边缘成分，实现图像增强的效果**)\n\n- 理想高通滤波器\n- 巴斯沃特高通滤波器\n- 高斯高通滤波器\n\n5.5 带阻滤波和带通滤波（**用于对某些区域的某一频率范围内的频率分量抑制其通过或让其通过**）\n\n## 第6章 图像恢复 ！！\n\n6.1.2 离散退化模型 $g(x,y) = H[f(x,y)]+n(x,y)$\n\n6.5 图像噪声与被噪声污染图像的恢复\n\n- 常用噪声\n  - 高斯噪声\n  - 瑞丽噪声\n  - 均匀分布噪声\n  - 脉冲噪声\n- 噪声分类\n  - 加性噪声（**独立于图像信号的噪声**）\n  - 乘性噪声（**噪声的幅值与图像本身的灰度值有关**）\n- 噪声恢复方法\n  - 谐波均值滤波（**善于处理像高斯噪声一类的噪声，对“盐”噪声处理效果很好，但不适用于对“胡椒”噪声的处理**）\n  - 逆谐波均值滤波（**适合于减少和消除椒盐噪声。当Q为正数时，用于消除“胡椒”噪声；当Q为负数时，用于消除“盐”噪声。但它不能同时消除“胡椒”噪声和“盐”噪声。当Q为-1时，逆谐波均值滤波器就退变成谐波均值滤波器**）\n  - 中点滤波（**结合了顺序统计和求平均的优点，对于高斯和均匀随机分布类噪声有很好的效果**）\n  - 自适应中值滤波（**去除“椒盐”噪声，平滑其他非冲击噪声，并减少诸如物体边界细节或粗化等失真**）\n\n6.6 几何失真的校正\n\n- 坐标的几何校正\n- 灰度值恢复\n\n坐标变换-灰度插值\n\n## 第7章 图像压缩编码\n\n7.1 DCT变换（离散余弦变换）\n\n- 和傅里叶变换的关系：仅保留傅里叶变换的实部\n\n## 第8章 小波图像处理\n\n8.1.1 小波的概念和特性\n\n- 小波是指小区域、长度有限、均值为0的振荡波形\n- 小波必须是振荡的；小波的振幅只能在一个很短的一段区间上非零\n- **小波变换弥补了傅里叶变换不能描述随时间变换的频率特性的不足，特别适合于那些在不同时间窗内具有不同频率特性，而且其应用目的是为了得到信号或图像的局部频谱信息而非整体信息的信号或图像处理问题**\n\n8.1.6 图像的小波变换\n\n- 小波变换关键问题\n  1. 小波变换层数的选择\n  2. 小波基的选取\n- 几种最基本的小波基\n  1. Haar小波\n  2. 墨西哥草帽小波\n\n8.3 基于小波变换的图像去噪方法（**去除噪声的同时又能较好地保留图像特征**）\n\n- 小波去噪特点\n  1. 低熵性\n  2. 多分辨率性\n  3. 去相关性\n  4. 选基灵活性\n- 阈值去噪步骤\n  1. 选择小波函数并确定分解层数N(一般N=3)\n  2. 对图像信号进行小波分解，将图像信号分解为低频和高频信息，而噪声部分通常包含在高频中\n  3. 对小波分解的高频系数进行阈值量化处理\n  4. 利用小波分解的第N层低频系数和经过阈值量化处理后的1~N层高频系数进行小波重构(小波反变换)，重构后得到的图像即是去噪后的图像\n- 小波收缩阈值去噪方法\n  1. 硬阈值处理(**硬阈值算法可以很好地保留图像边缘等局部特征；对含有丰富边缘的图像中产生许多“人为的”噪声点，图像会出现振铃、伪吉布斯效应等失真现象**)\n  2. 软阈值处理(**该算法处理结果相对于硬阈值处理平滑了许多，但造成了一定的高频信息损失，会导致图像边缘出现一定程度的模糊失真**)\n\n\n## 第9章 图像分割\n\n9.2.2 Hough变换\n\n- 基本思想是将图像空间X-Y变换到参数空间P-Q，利用图像空间X-Y与参数空间P-Q的点————线对偶性，通过把原始图像中给定形状的直线或曲线变换成参数空间的一个点，即原始图像中给定形状的直线或曲线变换成参数空间的一个点，即原始图像中给定形状的直线或曲线上的所有点都集中到参数空间的直线相交的某个点上而形成峰值（点数目累积的值）。这样，就把原始图像中给定形状的直线或曲线的检测问题，变成了寻找变换空间中的峰点问题，也把检测整体特性变成检测局部特性的问题。\n\n9.3.1 基于阈值的分割方法\n\n- 基于阈值的图像分割方法是提取物体与背景在灰度上的差异，把图像分为具有不同灰度级的目标区域和背景区域的一种图像分割技术\n\n9.4基于跟踪的图像分割\n基于跟踪的图像分割方法是先通过对图像上的点的简便运算，检测出可能存在的物体上的点，然后在检测到的点的基础上通过跟踪运算来检测物体的边缘轮廓的一种图像分割方法。这种方法的特点是跟踪计算不需要在每个图像点上都进行，只需要在已检测到的点和正在跟踪的物体的边缘轮廓延伸点上进行即可。\n\n- 轮廓跟踪法\n  1. 在靠近边缘处任取一起始点，然后按照每次只前进一步，步距为一个像素的原则开始跟踪。\n  2. 当跟踪中的某步是由白区进入黑区时，以后各步向左转，直到穿出黑区为止\n  3. 当跟踪中的某步是由白区进入白区时，以后各步向右转，直到穿出白区为止\n  4. 当围绕目标边界循环跟踪一周回到起点时，则所跟踪的轨迹便是目标的轮廓；否则，应按步骤2和步骤3的原则继续进行跟踪\n- 光栅跟踪法\n  1. 确定检测阈值d和跟踪阈值t，且要求d>t\n  2. 用检测阈值d逐行对图像进行扫描，依次将灰度值大于或等于检测阈值d的点的位置记为1\n  3. 逐行扫描图像，若图像中的(i,j)点为接受对象点，则在第i+1行上找点(i,j)的邻点(i+1,j-1)、(i+1,j)、(i+1,j+1)，并将其中灰度值大于或等于跟踪阈值t的邻点确定为新的接受对象点，将对应位置记为1\n  4. 重复步骤3，直至图像中除最末一行以外的所有接受点扫描完为止。此时位置为1的像素点连成的曲线即为检测到的边缘\n\n9.5 基于区域的图像分割\n\n- 区域生长法(**根据事先定义的相似性准则，将图像中满足相似性准则的像素或子区域聚合成更大区域的过程**)\n- 分裂合并法(**根据事先确定的分裂合并准则，也即区域特征一致性的测度；从整个图像出发，根据图像中各区域的不一致性，把图像或区域分裂成新的子区域；同时，可查找相邻区域有没有相似的特征，当相邻子区域满足一致性特征时，把它们合并成一个较大区域，直至所有区域不再满足分裂和合并的条件为止**)\n\n## 第10章 图像特征提取\n\n10.1 图像的边缘特征及其检测方法\n\n- 图像边缘特征：具有方向和幅度两个特征。\n  - 沿边缘走向，像素的灰度值变化比较平缓。\n  - 沿垂直于边缘的走向：像素的灰度值则变化比较剧烈。这种剧烈变化或者呈阶跃状，或者呈屋顶状，分别称为阶跃状边缘和屋顶状边缘。\n- 图像特征分为自然特征和人工特征两大类\n  - 人工特征是指人们为了便于对图像进行处理和分析而认为认定的图像特征，比如图像直方图、图像频谱图和图像的各种统计特征（图像的平均值、图像的方差、图像的标准差、图像的熵）\n  - 自然特征是指图像固有的特征，比如图像中的边缘、角点、纹理、形状和颜色等\n  - 三种典型边缘检测算子的性能分析：从总体上看，梯度算子对于噪声都有一定的敏感性，所以比较适用于图像边缘灰度值比较尖锐，且图像中噪声比较小的情况下应用（roberts，sobel，Prewitt）\n\n10.2 图像的点与角点特征及其检测方法          \n\n-  图像中的点分为一般意义上的点（也称为孤立像素点）和角点两点\n\n   - 角点的特征是一种非常重要和直观的图像特征，角点的特征有计算简单、计算量少，且对旋转、平移和缩放具有不变性等特点。\n   - 图像点：如果图像中一个非常小的区域的灰度幅值与其领域相比有着明显的差异，则称这个非常小的区域称为图像点。\n\n-  角点检测方法\n\n   - 基于模板的角点检测算法\n   - 基于边缘的角点检测算法\n   - 基于图像灰度变化和角点检测算法（**后两种检测算法最为广泛**）\n\n## 第11章 彩色图像处理\n\n11.1.1 三基色原理\n\n- 自然界中绝大多数颜色都可以分解成红，绿，蓝这三种颜色，这即是色度学中的三基色原理\n\n11.2.1 RGB彩色模型\n\n- 在RGB彩色模型中，每一幅图像都由R、G、B这3个基色图像分量表示。在彩色监视器应用中，当反映同一副图像的R，G，B三基色图像分量同时送入RGB监视器，这三幅图像就在荧光屏上混合产生一幅合成的彩色图像\n\n11.2.2 HSI彩色模型\n\n- HSI彩色模型模型常用于观察者进行彩色匹配实验和艺术家所使用，比较适合于人们用色调（H）、饱和度（S）和亮度（I）描述被观察物体颜色的解释，对于开发基于彩色描述的图像处理方法是一个理想的工具\n\n11.3.2 彩色图像的灰度化\n\n- 将彩色图像转变为灰度图像的处理称为彩色图像的灰度化处理\n\n11.3.3 真彩色转变为256色\n\n- 由于硬件条件的限制和某些应用的需求，有时需要将真彩色图像转化为256色图像进行显示。\n- 将真彩色图像转化为256色图像会有大量的颜色信息损失掉，因此，在转换过程中要找到合适的映射关系，使得变化后的256种颜色在原图像中最具代表性或出现的频率最高\n  - 中位切分法\n  - 流行色法\n\n11.3.4 彩色平衡\n\n- **为什么要做彩色平衡**：由于光源颜色、环境反射、成像设备缺陷等，会导致拍摄或图像数字化后的图像中的颜色在显示时看起来有些不正常，即景物中物体的颜色偏离了它原来的真实色彩。\n- 彩色平衡就是通过对色彩偏移的图像进行色彩校正，也即通过调整的图像R，G，B 3个分量的强度，恢复图像场景原始颜色特征的技术和过程\n\n11.4 彩色图像增强\n\n- **为什么要做彩色图像增强**：在得到的彩色图像中，有时会存在在**对比度低、颜色偏暗、局部细节**不明显等问题，为了**改善图像的视觉效果、突出图像的特征**，利于进一步的处理。\n- 真彩色增强\n  - 亮度增强   \n  - 色调增强\n  - 饱和度增强\n- 伪彩色增强\n  - 密度分层法\n  - 灰度级-彩色变换法\n  - 频率滤波法\n- 假彩色增强\n  - **二者的不同**：假彩色增强与伪彩色 增强不同，它是一幅初始的彩色图像或者从多光谱图像的波段中生成增强的彩色图像的一种方法，其实质是从一幅彩色图像映射到另一幅彩色图像，由于得到的彩色图像不再能反映原图像的真实色彩，因此称为假彩色增强\n\n11.5 彩色图像的平滑\n\n- 由于光照，摄影设备以及图像传输等原因，在得到彩色图像中不可避免地存在噪声。为了得到质量较高的彩色图像，要通过对图像的平滑处理消除这些噪声。\n\n11.6 彩色图像的锐化\n\n11.7 彩色图像的边缘检测\n\n11.8 彩色图像的分割\n\n- 彩色图像分割：利用图像的彩色信息，将图像分割为一些感兴趣区域的图像处理方法。彩色图像的分割可以看作是灰度图像分割向彩色空间的一种扩展和延伸\n\n## 第12 形态学图像处理\n\n12.2.1 腐蚀 \n\n- 腐蚀是一种最基本的数学形态学运算，所有其他形态学运算均可以在这一算的基础上导出。\n\n12.2.2 膨胀\n\n- 膨胀运算的概念\n- 结构元素形状对膨胀运算结果的影响\n- 膨胀运算的应用\n\n12.2.3 开运算和闭运算\n\n- 开运算：使用同一结构元素对目标图像先进行腐蚀算，然后再进行膨胀运算称为开运算\n- 闭运算：闭运算是开运算的对偶运算，使用同一结构元素对目标图像先进行膨胀运算，再进行腐蚀运算成为闭运算\n\n12.3 二值图像的形态学处理\n\n- 形态滤波\n- 边界提取\n- 区域填充\n- 骨架处理\n- 物体识别\n\n## 第13章 目标表示与描述\n\n13.1 边界表示\n\n- 边界的描述方法\n  - 链码\n  - 多边形\n  - 标记\n  - 边界线段\n\n13.2.3 傅里叶描述子\n\n- 边界点的复数表示：s(k) = x(k) + jy(k) \n\n## 第14章 视频图像处理基础\n\n14.1 视频图像处理概念\n\n+ 视频图像处理是指对视频图像信息进行变换，加工和分析，提高图像质量或提取图像中某些特殊信息。\n\n14.2 基于视频图像的运动目标检测与识别\n\n- 帧差法\n- 背景减法\n- 光流场分析法\n\n","tags":["技术探究"],"categories":["技术"]},{"title":"操作系统重点知识整理","url":"/2020/12/26/操作系统重点知识整理/","content":"\n万恶的期末考试要来了，这里做一个简单的操作系统重点知识整理。核心的部分会放在进程，处理机调度和死锁以及处理器那一块。持续更新......     co-author: [@czhorz](https://github.com/czhorz)\n\n<!--more-->\n\n## 第一章 操作系统引论\n\n- [x] 完成\n\n1. 设计现代OS的主要目标是什么？\n\n有效性，方便性，可扩充性，开放性\n\n2. OS的作用可表现在哪几个方面？\n\n（1）OS 作为用户与计算机硬件系统之间的接口\n（2）OS 作为计算机系统资源的管理者\n（3）OS 实现了对计算机资源的抽象\n\n3. 为什么说操作系统实现了对计算机资源的抽象？\n\nOS 首先在裸机上覆盖一层I/O 设备管理软件，实现了对计算机硬件操作的第一层次抽象；在第一层软件上再覆盖文件管理软件，实现了对硬件资源操作的第二层次抽象。OS 通过在计算机硬件上安装多层系统软件，增强了系统功能，隐藏了对硬件操作的细节，由它们共同实现了对计算机资源的抽象。\n\n4. 何谓脱机I/O和联机I/O？\n\n脱机I/O 是指事先将装有用户程序和数据的纸带或卡片装入纸带输入机或卡片机，在外围机的控制下，把纸带或卡片上的数据或程序输入到磁带上。该方式下的输入输出由外围机控制完成，是在脱离主机的情况下进行的。而联机I/O 方式是指程序和数据的输入输出都是在主机的直接控制下进行的。\n\n5. 什么是硬实时任务和软实时任务？举例\n\n实时任务是指系统必须满足任务对截止时间的要求，否则可能出现难以预测的结果。\n举例来说，运载火箭的控制等。\n软实时任务是指它的截止时间并不严格，偶尔错过了任务的截止时间，对系统产生的影响不大。举例：网页内容的更新、火车售票系统。\n\n6. 试从交互性、及时性以及可靠性方面将分时系统与实时系统进行比较。\n\n（1）及时性：实时信息处理系统对实时性的要求与分时系统类似，都是以人所能接受的等待时间来确定；而实时控制系统的及时性，是以控制对象所要求的开始截止时间或完成截止时间来确定的，一般为秒级到毫秒级，甚至有的要低于100 微妙。\n（2）交互性：实时信息处理系统具有交互性，但人与系统的交互仅限于访问系统中某些特定的专用服务程序。不像分时系统那样能向终端用户提供数据和资源共享等服务。\n（3）可靠性：分时系统也要求系统可靠，但相比之下，实时系统则要求系统具有高度的可靠性。因为任何差错都可能带来巨大的经济损失，甚至是灾难性后果，所以在实时系统中，往往都采取了多级容错措施保障系统的安全性及数据的安全性。\n\n7. OS有哪几大特征？其最基本的特征是什么？\n\n并发性、共享性、虚拟性和异步性四个基本特征；最基本的特征是并发性。\n\n8. **什么是时分复用技术？举例说明它能提高资源利用率的根本原因是什么？**\n\n时分复用技术:将资源在不同的时间片内分配给各进程以使该资源被重复利用,从而提高资源的利用率。如采用时分复用技术的虚拟处理机,能够在不同的时间片内处理多个用户的请求, 从而使得用户感觉自己独占主机,而处理机在这期间也被充分的利用\n\n9. 是什么原因使操作系统具有异步性特征？\n\n操作系统的异步性体现在三个方面：\n一是进程的异步性，进程以人们不可预知的速度向前推进，\n二是程序的不可再现性，即程序执行的结果有时是不确定的，\n三是程序执行时间的不可预知性，即每个程序何时执行，执行顺序以及完成时间是不确定的。\n\n10. 处理机管理有哪些主要功能？其主要目的是什么？\n\n处理机管理的主要功能是：进程管理、进程同步、进程通信和处理机调度；\n进程管理：为作业创建进程，撤销已结束进程，控制进程在运行过程中的状态转换。\n进程同步：为多个进程（含线程）的运行进行协调。\n通信：用来实现在相互合作的进程之间的信息交换。\n处理机调度：\n（1 ）作业调度。从后备队里按照一定的算法，选出若干个作业，为他们分配运行所需的资源（首选是分配内存）。\n（2 ）进程调度：从进程的就绪队列中，按照一定算法选出一个进程，把处理机分配给它，并设置运行现场，使进程投入执行。\n\n11. 内存管理有哪些主要功能 ? 他们的主要任务是什么？\n\n内存管理的主要功能有：内存分配、内存保护、地址映射和内存扩充。\n内存分配：为每道程序分配内存。\n内存保护：确保每道用户程序都只在自己的内存空间运行，彼此互不干扰。\n地址映射：将地址空间的逻辑地址转换为内存空间与对应的物理地址。内存扩充：用于实现请求调用功能，置换功能等。\n\n12. 设备管理有哪些主要功能？其主要任务是什么？\n\n主要功能有: 缓冲管理、设备分配和设备处理以及虚拟设备等。\n主要任务:  完成用户提出的I/O 请求，为用户分配I/O 设备；提高CPU 和I/O 设备的利用率；提高I/O 速度；以及方便用户使用I/O 设备.\n\n13. 文件管理有哪些主要功能？其主要任务是什么？\n\n文件管理主要功能：文件存储空间的管理、目录管理、文件的读/写管理和保护。文件管理的主要任务：管理用户文件和系统文件，方便用户使用，保证文件安全性。\n\n## 第二章 进程的描述与控制\n- [x] 完成\n\n1. 练习题，P91，T2\n2. 为什么程序并发执行会产生间断性特征？\n\n程序在并发执行时，由于它们共享系统资源，为完成同一项任务需要相互合作，致使这些并发执行的进程之间，形成了相互制约关系，从而使得进程在执行期间出现间断性。\n\n3. 在操作系统中为什么要引入进程概念？它会产生什么样的影响?\n\n为了使程序在多道程序环境下能并发执行，并对并发执行的程序加以控制和描述，在操作系统中引入了进程概念\n\n4. 试从动态性，并发性和独立性上比较进程和程序?\n\n(1)动态性是进程最基本的特性，表现为由创建而产生，由调度而执行，因得不到资源而暂停执行，由撤销而消亡。**进程有一定的生命期，而程序只是一组有序的指令集合，是静态实体。**\n(2)并发性是进程的重要特征，同时也是OS 的重要特征。引入进程的目的正是为了使其程序能和其它进程的程序并发执行，而程序是不能并发执行的。\n(3)独立性是指进程实体是一个能独立运行的基本单位，也是系统中独立获得资源和独立调度的基本单位。对于未建立任何进程的程序，不能作为独立单位参加运行。\n\n5. 试说明PCB 的作用，为什么说PCB 是进程存在的惟一标志？\n\nPCB 是进程实体的一部分，是操作系统中最重要的记录型**数据结构**。作用是使一个在多道程序环境下不能独立运行的程序，成为一个能独立运行的基本单位，成为能与其它进程并发执行的进程。OS是根据PCB对并发执行的进程进行控制和管理的。\n\n6. PCB提供了进程管理和进程调度所需要的哪些信息？\n\n进程管理：通用寄存器、指令寄存器、程序状态字、用户栈指针\n\n进程调度：进程状态、进程优先级、事件、其他信息\n\n6. 进程控制块的组织方式有哪几种？\n\n1）线性表方式：不论进程的状态如何，将所有的PCB连续地存放在内存的系统区。这种方式适用于系统中进程数目不多的情况。\n2）索引表方式：该方式是线性表方式的改进，系统按照进程的状态分别建立就绪索引表、阻塞索引表等。\n3）链接表方式：系统按照进程的状态将进程的PCB组成队列，从而形成就绪队列、阻塞队列、运行队列等。\n\n\n7. 何谓操作系统内核？内核的主要功能是什么？\n\n操作系统内核是指大多数操作系统的核心部分。它由操作系统中用于管理存储器、文件、外设和系统资源的那些部分组成。操作系统内核通常运行进程,并提供进程间的通信\n\n8. 试说明进程在三个基本状态之间转换的典型原因。\n\n（1）就绪状态→执行状态：进程分配到CPU资源\n（2）执行状态→就绪状态：时间片用完\n（3）执行状态→阻塞状态：I/O请求\n（4）阻塞状态→就绪状态：I/O完成\n\n10. 试从调度性、并发性、拥有资源及系统开销方面对进程和线程进行比较。\n\n（1）调度性。\n在传统的操作系统中，拥有资源的基本单位和独立调度、分派的基本单位都是进程，在引入线程的OS中，则把线程作为调度和分派的基本单位，而把进程作为资源拥有的基本单位；  \n（2）并发性。\n在引入线程的OS中，不仅进程之间可以并发执行，而且在一个进程中的多个线程之间，亦可并发执行，因而使OS具有更好的并发性； \n（3）拥有资源。\n无论是传统的操作系统，还是引入了线程的操作系统，进程始终是拥有资源的一个基本单位，而线程除了拥有一点在运行时必不可少的资源外，本身基本不拥有系统资源，但它可以访问其隶属进程的资源； \n（4）开销。\n由于创建或撤销进程时，系统都要为之分配和回收资源，如内存空间等，进程切换时所要保存和设置的现场信息也要明显地多于线程，因此，操作系统在创建、撤消和切换进程时所付出的开销将显著地大于线程。\n\n\n11. 线程控制块TCB包含了哪些内容？\n\n线程标识符\n\n一组寄存器\n   通用寄存器\n   程序计数器PC\n   状态寄存器\n\n线程运行状态\n\n优先级\n\n线程专有存储区\n\n信号屏蔽\n\n堆栈指针\n\n## 第三章 处理机调度和死锁\n\n- [x] 完成\n\n1. 高级调度与低级调度的主要任务是什么？为什么要引入中级调度？\n\n高级调度的主要任务是根据某种算法，把外存上处于后备队列中的那些作业调入内存。\n低级调度是保存处理机的现场信息，按某种算法先取进程，再把处理器分配给进程。\n引入中级调度的主要目的是为了提高内存利用率和系统吞吐量。\n使那些暂时不能运行的进程不再占用内存资源，将它们调至外存等待，把进程状态改为就绪驻外存状态或挂起状态。\n\n2. 处理机调度算法的共同目标是什么？批处理系统的调度目标又是什么？\n\n共同目标:资源利用率,公平性,平衡性,策略强制执行。 \n批处理系统的调度目标：平均周转时间短，系统吞吐量高，处理机利用率高。\n\n2. 在抢占调度方式中，抢占的原则是什么？\n\n抢占的原则有：时间片原则、优先权原则、短作业优先权原则等。\n\n4. 在选择调度方式和调度算法时，应遵循的准则是什么？\n\n面向用户的准则：周转时间短、响应时间快、截止时间的保证、优先权准则。\n面向系统的准则：系统吞吐量高、处理机利用率好、各类资源的平衡利用。\n\n5. 何谓静态和动态优先级？确定静态优先级的依据是什么？\n\n静态优先级是指在创建进程时确定且在进程的整个运行期间保持不变的优先级。\n动态优先级是指在创建进程时赋予的优先权， 可以随进程推进或随其等待时间增加而改变的优先级，可以获得更好的调度性能。 \n确定进程优先级的依据：进程类型、进程对资源的需求和用户要求。\n\n6. 试比较 FCFS 和 SPF 两种进程调度算法。\n\n相同点：两种调度算法都可以用于作业调度和进程调度。 \n不同点： \nFCFS  调度算法每次都从后备队列中选择一个或多个最先进入该队列的作业， 将它们调入内存、分配资源、创建进程、插入到就绪队列。该算法有利于长作业 /进程，不利于短作业 /进程。 \nSPF 算法每次调度都从后备队列中选择一个或若干个估计运行时间最短的作 业，调入内存中运行。该算法有利于短作业 /进程，不利于长作业 /进程。\n\n7. 在时间片轮转法中，应如何确定时间片的大小？\n\n时间片应略大于一次典型的交互需要的时间。 一般应考虑三个因素： 系统对相应时间的要求、就绪队列中进程的数目和系统的处理能力。\n\n8. 为什么说传统的几种调度算法都不能算是公平调度算法？\n\n传统的几种调度算法，都只能满足单条调度需求,对其他则不满足，如FCFS不利于短作业和IO型作业；SJF则不利于长作业和紧迫作业的运行；PSA不利于优先权低的作业;RR不利于紧迫作业。\n\n9. 保证调度算法是如何做到调度的公平性的？\n\n保证调度算法是另外一种类型的调度算法，它向用户所做出的保证并不是优先运行，而是明确的性能保证，该算法可以做到调度的公平性。\n一种比较容易实现的性能保证是处理机分配的公平性。如果在系统中有n个相同类型的进程同时运行，为公平起见，须保证每个进程都获得相同的处理机时间1/n。\n\n10. 按调度方式可将实时调度算法分为哪几种？\n\n按实时任务性质，可将实时调度的算法分为硬实时调度算法和软实时调度算法。\n\n按调度方式不同，可分为非抢占调度算法和抢占调度算法两种。\n\n11. 什么是最早截止时间优先调度算法？举例说明。\n\n根据任务的开始截止时间确定的任务优先级调度算法。 截止时间越早则优先级越高。 该算法要求在系统中保持一个实时任务就绪队列，该队列按各任务截止时间的先后排序。 举例：非抢占式调度方式用于非周期实时任务。\n\n12. 什么是最低松弛度优先调度算法？举例说明之\n\n该算法是根据任务紧急 ( 或松弛 )的程度，来确定任务的优先级。任务的紧急程度愈高， 为该任务所赋予的优先级就愈高，以使之优先执行。例如，一个任务在   200 ms 时必须完成，而它本身所需的运行时间就有 100 ms ，因此，调度程序必须在 100 ms 之前调度执行，该任务的紧急程度 (松弛程度 )为 100 ms 。又如，另一任务在 400 ms 时必须完成，它本身需要运行 150 ms ，则其松弛程度为 250 ms 。\n\n13. 何谓“优先级倒置”现象，可采用什么方法来解决？\n\n优先级倒置，高优先级进程被低优先级进程延迟或阻塞的现象。 解决方法可以是\n\n(1) 规定进程在进入临界区后，其所占有的处理机不允许被抢占。\n\n(2) 动态优先级继承\n\n14. 试举例说明竞争不可抢占资源所引起的死锁\n\n例如，系统中有两个进程P1和P2，它们都准备写两个文件F1和F2，而这两者都属于可重用和不可抢占性资源。进程P1先打开F1，然后再打开文件F2；进程P2先打开文件F2，后打开F1，下面示出了这段代码。\n```\n    　　P1\n\n   　　 P2\n\n  　　 .........\n\n   　　Open(f1,w)；　　　　 Open(f2,w)；\n\n    　　Open(f2,w)；　　　　  Open(f1,w)；\n```\n　　 两个进程P1和P2在并发执行时，如果P1先打开F1和F2，然后P2才去打开F1（或F2），由于文件F1（F2)已被P1打开，故P2会被阻塞。当P1写完文件F1（或F2）而关闭F1（F2)时，P2会由阻塞状态转为就绪状态，被调度执行后重新打开文件F1（或F2)。\n\n　　在这种情况下，P1和P2都能正常运行下去。若P2先打开F1和F2，然后P1才去打开F1（或F2），P1和P2同样也可以正常运行下去。\n\n   但如果在Pl打开F1的同时，P2去打开F2，每个进程都占有一个打开的文件，此时就可能出现问题。因为当P1试图去打开F2，而P2试图去打开F1时，\n\n　　这两个进程都会因文件已被打开而阻塞，它们希望对方关闭自己所需要的文件，但谁也无法运行，因此这两个进程将会无限期地等待下去，而形成死锁。\n\n15. 为了破坏“请求和保持”条件而提出了两种协议，试比较这两种协议\n\n第一种协议：所有进程在开始运行之前，必须一次性地申请其在整个运行过程中所需的全部资源。优点就是简单、易行且安全；缺点就是资源被严重浪费、进程经常发生饥饿现象。\n第二种协议：允许一个进程只获得运行初期所需的资源后，便开始运行。进程运行过程中再逐步释放已分配给自己的、且已用毕的全部资源，然后再请求新的所需资源。\n\n16. 何谓死锁？产生死锁的原因和必要条件是什么?\n\n死锁是指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。\n产生死锁的原因为竞争资源和进程间推进顺序非法。其必要条件是：互斥条件、请求和保持条件、不剥夺条件、环路等待条件。\n\n17. 请详细说明可通过哪些途径预防死锁。\n\n(1)摈弃“请求和保持”条件,就是如果系统有足够资源,便一次性把进程需要的所有资源分配给它; \n(2)摈弃“不剥夺”条件,就是已经拥有资源的进程,当它提出新资源请求而不能立即满足时,必须释放它已保持的所有资源,待以后需要时再重新申请;\n(3)摈弃“环路等待”条件,就是将所有资源按类型排序标号,所有进程对资源的请求必须严格按序号递增的次序提出\n\n18. 练习题，P128，T30\n19. 练习题，P128，T31\n\n## 第四章 存储器管理\n- [x] 完成\n\n1. 为什么要配置层次式存储器？\n\n设置多个存储器可以使存储器两端的硬件能并行工作；采用多级存储系统，特别是 Cache 技术，是减轻存储器带宽对系统性能影响的最佳结构方案；在微处理机内部设置各 种缓冲存储器，减轻对存储器存取的压力。增加CPU中寄存器数量大大缓解对存储器压力。\n\n2. 何谓静态链接？何谓装入时动态链接和运行时的动态链接？P120\n\n静态链接是指在程序运行前，先将各目标模块及它们所需的库函数，链接成一个完整的装配模块，以后不再拆开的链接方式。 \n\n3. 何谓装入时动态链接？有何优点？\n\n   装入时动态链接是指将用户源程序编译后得到的一组目标模块，在装入内存时采用边装入边链接的链接方式。\n\n   1.便于修改和更新\n\n   2.便于实现对目标模块的共享\n\n4. 何谓运行时动态链接？有何优点？\n\n   运行时动态链接是指对某些目标模块的链接，是在程序执行中需要该目标模块时，才对它进行的链接。\n\n   1.加快了程序的装入过程，节省大量的内存空间\n\n5. 为什么要引入动态重定位？如何实现？ \n\n在程序执行过程中，每当访问指令或数据时，将要访问的程序或数据的逻辑地址转换成 物理地址，引入了动态重定位； 具体实现方法是在系统中增加一个重定位寄存器，用来装入程序在内存中的起始地址， 程序执行时，真正访问的内存地址是相对地址与重定位寄存器中的地址相加之和，从而实现  动态重定位\n\n6. 在采用首次适应算法回收内存时，可能出现哪几种情况？应怎样处理这些情况？ \n\n在采用首次适应算法回收内存时可能出现4种情况： （1）回收区前邻空闲区。将回收区与前邻空闲区合并，将前邻空闲区大小修改为两者之和。 \n（2）回收区后邻空闲区。将两区合并，改后邻空闲区始址为回收区始址，大小为两者之和。 \n（3）回收区前后均邻空闲区。将三个分区合并，修改前邻空闲区大小为三者之和。 \n（4）回收区前后均不邻空闲区。为回收区设置空闲区表项，填入回收区始址和大小并插入 空闲区队列。\n\n7. 什么是基于索引搜索的动态分区匹配算法？它可分为哪几种？\n（1）快速适应算法 \n优点：查找效率高\n缺点：为了有效合并分区，分区归主存时的算法复杂，系统开销大。\n（2）伙伴系统 \n（3）哈希算法\n8. 练习题，P162，T11\n9. 对文件区管理的目标和对对换空间管理的目标有何不同？\n对文件区管理的主要目标是提高文件储存空间的利用率，其次才是提高对文件的访问速度。因此对文件区管理采取离散分配方式\n对对换空间管理的主要目标是提高进程换入换出的速度，其次才是提高文件储存空间的利用率。因此对对换空间的管理采取连续分配方式\n10. 在以进程为单位进行对换时，每次是否都将整个进程换出？为什么？\n在以进程为单位进行对换时，并非每次都将整个进程换出。这是因为： \n(1)从结构上讲，进程由程序段、数据段和进程控制块组成的，其中进程控制块总有部分或全部常驻内存，不被换出。 \n(2)程序段和数据段可能正被若干进程共享，此时它们也不能换出\n\n11. 什么是页面？什么是物理块？页面的大小应如何确定？\n页面：用户程序的地址空间分为若干个固定大小的区域\n物理块：内存的物理地址空间分为若干个块称为物理块\n页面大小为2的冥，通常为1KB-8KB\n12. 为实现分页存储管理，需要哪些硬件的支持？ \n页表寄存器\n动态重定位技术、虚拟存储技术、多道程序设计技术\n\n13. 在具有快表的页式存储管理方式中，如何实现地址变换？\n\n\t在CPU给出有效地址后，由地址变换机构自动将页号P送入高速缓冲寄存器，并将此 页号与高速缓存中的所有页号比较，若找到匹配页号，表示要访问的页表项在快表中。可直 接从快表读出该页对应物理块号，送到物理地址寄存器中。如快表中没有对应页表项，则再 访问内存页表，找到后，把从页表项中读出物理块号送地址寄存器；同时修改快表，将此页 表项存入快表。但若寄存器已满，则OS必须找到合适的页表项换出。\n\n14. 分页和分段存储管理有何区别？\n    （1）分页存储管理中，页是信息的物理单位。其目标是实现离散分配方式，消灭内存的碎片，提高内存利用率。分段储存管理中，段是信息的逻辑单位。其目标是更好地满足用户得需要。\n    （2）页的大小固定且由系统决定。段的长度不固定，决定于用户所编写的程序。\n    （3）分页是系统的行为。分页的用户程序地址空间是一维的。而分段是用户的行为，用户得地址空间是二位的。\n\n15. 试全面比较连续分配和离散分配方式。\n\n    ​\t连续分配是指为一个用户程序分配一个连续的内存空间。又可进一步分为单一连续分配、固定分区分配、动态分区分配和动态重定位分区分配四种方式。连续分区方式可使一个进程分得一个连续的内存空间，这样一来有利于程序的执行，但同时又会产生很多的碎片，浪费大量的系统资源。\n\n    ​\t离散分区是采用段式或页式或段页式的分配方式将一个进程装入一些离散的内存中，这样有利于内存的利用，并且可以方便程序员在更大的空间进行编程工作。\n\n## 第五章 虚拟存储器\n- [x] 完成\n\n1. 常规存储器管理方式具有哪两大特征？它对系统性能有何影响？\n\n   （1）一次性\n\n   导致大作业无法在小内存运行，以及无法进一提高系统的多道程序度，直接限制了对处理机的利用率和系统的吞吐量的提高\n\n   （2）驻留性\n\n   部分进程或者模块长期驻留内存，占用内存资源\n\n2. 什么是程序运行时的时间局限性和空间局限性？\n\n   时间局限性：如果程序中的某条指令被执行，则不久后该指令可能再次执行；如果程序中的某数据被访问过，则不久后该数据可能被再次访问。\n\n   空间局限性：程序在一段时间内所访问的地址可能集中在一定的范围内\n\n3. 实现虚拟存储器需要哪些硬件支持？\n\n（1）请求分页（段）的页（段）表机制（2）缺页（段）中断机构（3）地址变换机构\n\n4. 在请求分页系统中，页表应包括哪些数据项？每项的作用是什么？ \n\n页表应包括：页号、物理块号、状态位P、访问字段A、修改位M和外存地址。 其中状态位P 指示该页是否调入内存，供程序访问时参考；访问字段A 用于记录本页在一 段时间内被访问的次数，或最近已有多长时间未被访问，提供给置换算法选择换出页面时参 考；修改位M 表示该页在调入内存后是否被修改过；外存地址用于指出该页在外存上的地 址，通常是物理块号，供调入该页时使用。\n\n5. 试比较缺页中断机构与一般中断机构，他们之前有何明显的区别？\n\n   （1）在指令期间产生和处理中断信号。\n\n   （2）一条指令在执行期间可能产生多次缺页中断\n\n6. 试说明请求分页系统中的地址变换功过程。\n\n   1）取逻辑地址分解为页号P和页内偏移w；\n   2）根据页号查找页表，获得该页的描述信息；\n   3）若该页中断位为1，产生缺页中断；\n   4）更新该页的描述信息；\n   5) 根据页块号和页内偏移w，计算物理地址。\n\n7. 在请求分页系统中，应从何处将所需页面调入内存？ \n\n请求分页系统中的缺页从何处调入内存分三种情况： \n\n（1）系统拥有足够对换区空间时，可以全部从对换区调入所需页面，提高调页速度。在进程运行前将与该进程有关的文件从文件区拷贝到对换区。 \n（2）系统缺少足够对换区空间时，不被修改的文件直接从文件区调入；当换出这些页面时，未被修改的不必换出，再调入时，仍从文件区直接调入。对于可能修改的，在换出时便调到对换区，以后需要时再从对换区调入。\n（3）UNIX 方式。未运行页面从文件区调入。曾经运行过但被换出页面，下次从对换区调入。UNIX系统允许页面共享，某进程请求的页面有可能已调入内存，直接使用不再调入。\n\n8. **在请求分页系统中，常采用哪几种页面置换算法？**\n\n采用的页面置换算法有：最佳置换算法和先进先出置换算法，最近最久未使用（LRU）置换算法，Clock置换算法，最少使用置换算法，页面缓冲算法等\n\n9. 实现LRU算法所需的硬件支持是什么?\n\n需要寄存器和栈等硬件支持。寄存器用于记录某进程在内存中各页的使用情况，栈用于 保存当前使用的各个页面的页面号。\n\n10. 试说明改进型 Clock 置换算法的基本原理. \n\n因为修改过的页面在换出时付出的开销比未被修改过的页面大，在改进型Clock 算法 中，既考虑页面的使用情况，还要增加置换代价的因素；在选择页面作为淘汰页面时，把同 时满足未使用过和未被修改作为首选淘汰页面。 \n\n11. 影响页面换进换出频率的若干因素是什么？\n\n    对页面进行置换的算法，将已修改页面写回磁盘的频率，将磁盘内容读入内存的频率\n\n12. 页面缓冲算法（PBA）的主要特点是什么？它是如何实现的\n\n    （1）显著地降低了页面换进换出地频率，使磁盘IO操作次数大为减少。\n\n    （2）采用一种较简单的置换策略\n\n    实现：采用可变分配和局部置换方式，系统为每个进程分配一定数目的物理块，自己保留一部分空闲物理块，同时在内存中设置空闲页面链表和修改页面链表。\n\n13. **在请求分页系统汇总，产生“抖动”的原因是什么？**\n\n    **系统中同时运行的进程太多，每个进程分配的物理块太少，不能满足进程运行的基本要求，导致进程运行频繁缺页，必须访问将缺页调入内存。**\n\n14. 何谓工作集？它是基于什么原理确定的？\n\n    某段时间间隔里，进程实际要访问页面的集合。\n\n    原理：预知程序在某段时间间隔内要访问的页面，将他们调入内存，降低缺页率。\n\n15. 当前可以利用哪几种方式来防止“抖动”？\n\n    1.采取局部置换策略\n\n    2.把工集算法融入到处理机调度中\n\n    3.利用“L=S”准确调节缺页率\n\n    4.选择暂停的进程\n\n## 第六章 输入输出系统\n- [x] 完成\n1. 试说明IO系统的基本功能\n\n     1.方便用户使用IO设备\n\n     2.提高CPU和IO设备的利用率\n\n     3.为用户在共享设备时提供方便\n\n2. 简要说明IO软件的四个层次的基本功能\n\n     用户层IO软件，实现用户交互的接口\n\n     设备独立性软件，用于实现用户程序与设备驱动器的统一接口、设备命名、设备的保护以及设备的分配\n\n     和释放等，同时为设备管理和数据传送提供必要的储存空间\n\n     设备驱动程序，与硬件直接相关，用于具体实现系统对设备发出的操作指令、驱动IO设备工作的驱动程序\n\n     中断处理程序，用于保存被中断进程的cpu环境，转入相应的中断处理程序进行处理，处理完毕再恢复被\n\n     中断进程的现场后哦，返回被中断的进程\n\n3. IO系统接口与软件/硬件接口分别是什么接口\n\n     IO系统接口时IO系统与上层操作系统之间的接口。\n\n     软件/硬件接口是中断处理程序和设备控制器之间的接口\n\n4. 与设备无关性的基本含义是什么，为什么要设置该层\n\n     应用程序独立于具体使用的物理设备，为了提高OS的可适应性和可拓展性\n\n5. 为了实现cpu与设备控制器间的通信，设备控制器应该具备哪些功能\n\n     （1）接受和识别命令\n\n     （2）数据交换\n\n     （3）标识和报告设备的状态\n\n     （4）地址识别\n\n     （5）数据缓冲区\n\n     （6）差错控制\n\n6. 什么是内存映像IO？他是如何实现的\n\n     1.利用特定的IO指令  \n\n     缺点：访问内存和访问设备需要两种不同的指令\n\n     2.内存映像IO\n\n     在编址上不再区分内存单元地址和设备控制器中的寄存器地址，采用k。k属于0---n-1时，被认为时内存地址，大于等于n时，被认为是某个控制器的寄存器地址\n\n7. 为什么说中断是os赖以生存的基础\n\n     进程的切换是通过中断完成的，中断也是设备管理的基础\n\n8. 设备中断处理程序通常需要完成哪些工作\n\n     1. 测定是否有未响应的中断信号\n     2. 保护被终端进程的cpu环境\n     3. 转入相应的设备处理程序\n     4. 中断处理\n     5. 恢复cpu的现场并退出中断\n\n9. 简要说明中断处理程序对中断进行处理的几个步骤\n\n   ①关中断，进入不可再次响应中断的状态，由硬件实现。\n   ②保存断点，为了在中断处理结束后能正确返回到中断点。由硬件实现。\n     ③将中断服务程序入口地址送PC，转向中断服务程序。可由硬件实现，也可由软件实现。\n   ④保护现场、置屏蔽字、开中断，即保护CPU中某些寄存器的内容、设置中断处理次序、允许更高级的中断请求得到响应，实现中断嵌套。由软件实现。\n     ⑤设备服务，实际上有效的中断处理工作是在此程序段中实现的。\n\n     ⑥退出中断。\n\n10. 试说明推动IO控制发展的主要因素是什么\n\n      尽量减少主机对IO控制的干预，把主机从繁杂的IO控制事务中解脱\n\n11. 有哪几种IO控制方式，分别适用于何种场合\n\n      I/O控制方式：程序I/O方式、中断驱动I/O控制方式、DMAI/O控制方式、I/O通道控制方式。\n\n      程序I/O方式适用于早期的计算机系统中，并且是无中断的计算机系统；\n\n      中断驱动I/O控制方式是普遍用于现代的计算机系统中；\n\n      DMA  I/O控制方式适用于I/O设备为块设备时在和主机进行数据交换的一种I/O控制方式；\n\n      当I/O设备和主机进行数据交换是一组数据块时通常采用I/O通道控制方式，但此时要求系统必须配置相应的通道及通道控制器。\n    \n12. 试说明DMA的工作流程\n\n      （1）CPU需要访问外存时便发送。一条访问命令给DMA的命令寄存器CR、一个内存地址码给DMA的内存地址寄存器MAR、本次要传送的字节数给DMA的数据计数器DC、外存地址给DMA的I/O控制逻辑。\n\n      （2）CPU启动DMA控制器后转向其他处理。\n\n      （3）DMA控制器负责控制数据在内存与外设之间传送。每传送一个字节就需挪用一个内存周期，按MAR从内存读出或写入内存一个字节，修改MAR和计算器DC。\n\n      （4）当DC修改为0时，表示传送结束，由DMA向CPU发出中断请求。\n\n13. 为何要引入与设备的无关性，如何实现设备的独立性\n  \n    引入设备独立性，可使应用程序独立于具体的物理设备，是设备分配具有灵活性。另外容易实现I/0重定向。为了实现设备独立性，必须在设备驱动程序之上设置一层设备独立性软件，用来执行所有I/0设备的公用操作，并向用户层软件提供统一接口。\n  \n    关键是系统中必须设置一张逻辑设备表LUT用来进行逻辑设备到物理设备的映射，其中每个表目中包含了逻辑设备名、物理设备名和设备驱动程序入口地址三项；\n  \n    当应用程序用逻辑设备名请求分配I/0设备时，系统必须为它分配相应的物理设备，并在LUT中建立一个表目，以后进程利用该逻辑设备名请求I/0操作时，便可从LUT中得到物理设备名和驱动程序入口地址。\n  \n14. 何为设备虚拟，实现设备虚拟时所依赖的关键技术是什么\n  \n15. 引入缓冲的主要原因是什么\n  \n      1. 缓和cpu与io设备间速度不匹配的矛盾\n      2. 减少对cpu的中断频率，放宽对cpu中断响应时间的限制\n      3. 解决数据粒度不匹配的问题\n      4. 提高cpu和io设备之间的并行性\n  \n16. 在单缓冲情况下，为什么系统对一块数据的处理时间为max(C，T）+M\n  \n17. 为什么双缓冲情况下系统对一块数据的处理时间为max(C，T）\n  \n18. 目前常用的磁盘调度算法有哪几种，每种算法优先考虑的问题是什么\n  \n      1. 先来先服务(FCFS)\n      \n         根据进程请求访问次磁盘的先后次序进行调度\n      \n      2. 最短寻道时间优先(SSTF)\n      \n         要求访问的磁道与当前磁头所在的磁道距离最近\n      \n      3. 扫描算法(SCAN)\n      \n         优先考虑磁头当前的移动方向，再考虑欲访问的磁道与当前磁道的距离\n      \n      4. 循环扫描算法(CSCAN)\n      \n         CSCAN算法规定磁头单向移动，避免了扫描算法导致的某些进程磁盘请求的严重延迟。\n      \n      5. NStepSCAN算法\n      \n          为克服前述SSTF、SCAN、CSCAN等调度算法都可能出现的磁臂停留在某处不动的情况即磁臂粘着现象，将磁盘请求队列分成若干个长度为N的子队列，按先来先服务算法依次处理这些子队列，而各队列分别以扫描算法进行处理。\n        \n      6. FSCAN算法\n      \n         它只将磁盘请求访问队列分成两个子队列。一是当前所有请求磁盘I/O的进程形成的队列，由磁盘调度按SCAN算法进行处理。另一个队列则是在 扫描期间，新出现的所有请求磁盘I/O进程的队列，放入另一等待处理的请求队列。这样，所有的新请求都将被推迟到下一次扫描时处理。\n\n## 第七章 文件管理\n- [x] 完成\n\n1. 何谓文件的逻辑结构，何谓文件的物理结构\n\n     逻辑结构：文件是由一系列的逻辑记录组成的，是用户可以直接处理的数据及其结构。\n\n     物理结构：系统将文件储存在外存上所形成的一种构成形式\n\n2. 按文件的组织方式可将文件分为几种类型\n\n     1. 顺序文件\n     2. 索引文件\n     3. 索引顺序文件\n\n3. 通过哪两种方式来固定长记录实现随机访问\n\n     1. 隐式寻址方式\n     2. 显式寻址方式\n\n4. 对目录管理的主要要求是什么\n\n     1. 实现“按名存取”。用户只需向系统提供所需访问文件的名字，就能快速准确地找到指定文件在外存上地储存位置\n     2. 提高对目录的检索速度\n     3. 文件共享\n     4. 允许文件重名\n\n5. 何谓路径名和当前目录\n\n     路径名：从根目录到任何数据文件都只有一条唯一的路。从主目录开始，把全部目录文件名与数据文件名依次用“/”连\n\n     接起来，构成该数据文件唯一的路径名\n\n     当前目录：当前用户所在的路径（不太确定）\n\n6. Hash检索法有何优点，又有何局限性\n\n     优点：将用户提供的文件名转换为文件目录的索引值，再使用索引值到目录中寻找。能显著提升检索速度\n\n     局限：对于使用了通配符的文件名，无法使用Hash检索法转换文件名，只能使用线性检索法\n\n7. 试说明在树形目录结构中线性检索法的检索过程，并给出相应的流程图\n\n     Level2/„/Leveln/datafile，则关于树型目录结构采用线性检索法检索该文件的基本过程为：\n\n     ①读入第一个文件分量名Level1，用它与根目录文件（或当前目录文件）中各个目录项的文件名顺序地进行比较，从中找出匹配者，并得到匹配项的索引结点号，再从对应索引结点中获知Level1目录文件所在的盘块号，将相应盘块读入内存。\n\n     ②对于2~n，循环执行以下步骤，以检索各级目录文件：读入第i个文件分量名Leveli，用它与最新调入内存的当前目录文件中各个目录项的文件名顺序地进行比较，从中找出匹配者，并得到匹配项的索引结点号，再从对应索引结点中获知Leveli目录文件所在的盘块号，将相应盘块读入内存。\n     ③读入最后一个文件分量名即datafile，用它与第n级目录文件中各个目录项的文件名进行比较，从而得到该文件对应的索引结点号，进而找到该文件物理地址，目录查找操作成功结束。如果在上述查找过程中，发现任何一个文件分量名未能找到，则停止查找并返回“文件未找到”的出错信息\n\n8. 什么是主父目录，如何利用符号链实现共享\n\n     允许一个文件或者子目录有多个父目录，但是其中只有一个作为主父目录。\n\n     例如目录D想共享某个文件，系统创建一个LINK类型的新文件，该新文件只包含要链接的文件的路名名。将该新文件写入想要目录D中\n\n9. 基于符号链的文件共享方式有何优点\n\n     只有文件主才有指向其索引结点的指针，共享该文件的其他用户只有路径名。在文件主删除文件时，不会留下悬空指针。其他用户通过符号链访问已删除的共享文件时，会因为找不到指针而访问失败，然后删除符号链，这样不会产生任何影响。（感觉像快捷方式）\n\n10. 什么是保护域，进程和保护域之间存在的动态联系是什么\n\n      保护域简称为“域”，他是进程对一组对象访问权的集合，进程只能在制定域内执行操作。\n\n      动态联系：一个进程连续着多个域。进程运行分为多个阶段，每个阶段联系着一个域。在运行时根据实习需要来规定进程运行的\n\n      每个阶段中能访问的对象\n\n## 第八章 磁盘存储器的管理\n- [x] 完成\n\n1. 目前常用的外存有哪几种组织方式\n\n     1. 连续组织方式\n     2. 链接组织方式\n     3. 索引组织方式\n\n2. 由连续组织方式所形成的顺序文件的主要优缺点时什么，主要应用于何种场合\n\n     （1）连续组织方式所形成的顺序文件的主要优点\n\n     ①顺序访问容易\n\n     访问连续文件非常容易，系统可从目录中找到该顺序文件所在的第一个盘块号，从此开始逐个盘块地往下读，写。连续分配也支持对定长记录的文件进行随机存取。\n\n     ②顺序访问速度快\n\n     由连续分配所装入的文件，其所占用的盘块可能是位于一条或几条相邻的磁道上，磁头的移动距离最少，因此，这种对文件访问的速度是几种存储空间分配方式中最高的一种。\n\n     （2）连续组织方式所形成的顺序文件的主要缺点\n\n     ①要求为一个文件分配连续的存储空间\n\n     由内存的连续分配得知，这样便会产生出许多外部碎片，严重地降低了外存空间的利用率。如果是定期地利用紧凑方法来消除碎片，则又需花费大量的机器时间。\n\n     ②必须事先知道文件的长度\n\n     要将一个文件装入一个连续的存储区中，必须事先知道文件的大小。知道文件的大小有时只能靠估算，如果估计的文件大小比实际文件小，就会因存储空间不足而中止文件的拷贝，要求用户重新估算后再次拷贝。这就促使用户将文件长度估得比实际的大，从而造成浪费。\n\n     ③不能灵活地删除和插入记录\n\n     为保持文件的有序性，在删除和插入记录时，都需要对相邻的记录做物理上的移动，还会动态地改变文件的大小。\n\n     ④对于那些动态增长的文件，由于事先很难知道文件的最终大小，因而很难为其分配空间，而即使事先知道文件的最终大小，在采用预分配存储空间的方法时，也会使大量的存储空间长期空闲。\n\n     （3）主要适用场合\n\n     连续组织方式所形成的顺序文件是一种最简单、最常用的文件组织方法，它适用于许多资料处理的场合，如磁带文件，打印文件都是常用的顺序文件。\n\n3. 在链接式文件中常用哪种链接方式，为什么\n\n     常使用显式链接，隐式链接组织方式只适合顺序访问，随机访问的速度很低。而且隐式链接组织方式只通过链接指针将离散的盘块链接起来，可靠性较差。而显式链接查找记录的过程式在内存中进行的，显著地提高了检索速度和减少了访问磁盘的次数。\n\n4. 简要说明为什么要从FAT12发展为FAT16,又进一步发展为FAT32\n\n     FAT12存在主要问题：FAT12表中的表项有限制，最多只允许4096个。因此，随着磁盘的增加，簇的大小和簇内碎片也随之增加。限制了磁盘的最大容量。同时FAT12只能支持短文件名。为了解决FAT12限制磁盘容量的问题，FAT的表项位数增至2的16次方个。发展为FAT16，但是磁盘容量迅速增加时，簇的容量必须很大，簇内碎片造成的浪费也很大。因此FAT进一步发展为FAT32\n\n5. P297   T11 \n\n6. P297   T14\n\n## 第九章 操作系统接口\n- [x] 完成\n\n1. 操作系统用户接口中包括哪几种接口？他们分别适用于哪种情况\n\n操作系统包括四种类型的用户接口：命令接口（分为联机与脱机命令接口）、程序接口、图形化用户接口和网络用户接口。\n命令接口和图形化用户接口支持用户直接通过终端来使用计算机系统，程序接口提供给用户在编制程序时使用，网络用户接口是面向网络应用的接口。\n\n2. 联机命令通常包含哪些类型？每种类型又包含哪些主要命令？\n\n联机命令通常包含如下类型：\n（1 ）系统访问类，主要是注册命令login 、password ；（2 ）磁盘操作类，包括磁盘格式化format 、软盘复制diskcopy 、软盘比较diskcomp 及备份backup 等命令；（3 ）文件操作类，包括文件显示type 、文件拷贝copy 、文件比较comp 、文件重命名rename 、文件删除erase 等命令\n（4 ）目录操作类，包括子目录建立mkdir 、目录显示dir 、子目录删除rmdir 、目录结构显示tree 、当前目录改变chdir 等命令；（5 ）其它命令，包括输入输出重定向>、<, 管道联接|、过滤命令/,批命令.bat 等。\n\n3. 什么是输入输出重定向？试举例说明。\n\n命令的输入通常取自标准输入设备键盘，命令输出则送往标准输出设备显示终端。如果在命令中设置输出定向“>，”其后接文件或设备名，则命令的结果输出将送到指定文件或设备上；如果使用输入重定向“<，”则不从键盘而是从重定向符右边的指定文件或设备上取得输入信息。这就是输入输出的重定向。\n\n4. 何谓管道联接？试举例说明。\n\n管道联接是指把第一个命令的输出作为第二个命令的输入，或把第二个命令的输出作为第三条命令的输入，以此类推，由两条以上的命令可形成一条管道。在MS-DOS 和UNIX 中，都用\"|\" 作为管道符号。其一般格式为：command1 |command2 | |commandn 。\n\n5. 联机命令接口由哪些部分构成？\n\n联机命令接口由一组联机命令、终端处理程序和命令解释程序构成。\n\n6. 终端设备处理程序的主要作用是什么？它具有哪些功能？\n\n主要用于实现人机交互，它具有以下功能：\n（1）接收用户从终端上键入的字符；\n（2）字符缓冲，用于暂存接收的字符；\n（3）回送显示；\n（4）屏幕编辑；\n（5）特殊字符处理。\n\n## 致谢\n\n---------\n\n感谢[@czhorz](https://github.com/czhorz)对本文的支持\n\n\n","tags":["技术探究"],"categories":["技术"]},{"title":"回形针与10个批评者聊天","url":"/2020/10/07/回形针与10个批评者聊天/","content":"\n> 知乎的朋友们好，我是回形针（可能你们都叫两面针）的吴松磊。\n  11 天前，我们发布了最近半年的工作汇报，视频结尾发起了一个活动招募，邀请各位批评回形针的观众朋友和我一块视频聊天。\n 「我们大概会选出 10 个人，你们可以当面直接喷我，聊点让我尴尬的东西。」\n\n我从回形针第100期开始看回形针，那一期是一个十分精彩的闯关类小游戏的预告。正好在我做完软协1024活动之后，我痴迷于这种游戏。紧接着我补完了回形针的所有视频，我喜欢这种理性的表达方式和一种所谓的了解了知识的快乐。我一度想成为回形针手册的编纂志愿者。突然有一天，“肉蛋奶”，“地图和标题内外网不一致”出现在我的时间线上。这一场互联网狂欢开始。作为全程的旁观者，我认为[《【回形针PaperClip】和 10 个批评者一块聊天》](https://www.bilibili.com/video/BV11i4y177nd)这个视频应该标志着这场闹剧暂时性的落幕了。这到底是一个“屁股”的问题，还是一个“网暴”的问题。我现在也看不真切。但是看完2个多小时的聊天全记录后，得以一窥操控键盘的人。\n\n<!--more-->\n\n","tags":["随笔","思考"],"categories":["随笔"]},{"title":"Vue","url":"/2020/09/20/vue/","content":"\ntags: [] [解决方案] [思考] [随笔]\n\n<!--more-->\n\n","tags":["技术探究"],"categories":["技术"]},{"title":"微信读书","url":"/2020/06/01/微信读书/","content":"\n微信读书已经推出有一定的时间了。以往在学校，小说自然有看小说的网站，读书自然就去学校图书馆。微信读书成为了可有可无的东西。但是随着疫情的到来，坐在家中，书籍的获得变的前所未有的困难起来。回想起去年送出的kindle，竟有些后悔。\n\n<!--more-->\n\n","tags":["随笔","思考"],"categories":["读书"]},{"title":"计网-网络层","url":"/2020/06/01/计网-网络层/","content":"\n> 网络层是[OSI参考模型](https://baike.baidu.com/item/OSI参考模型)中的第三层，介于[传输层](https://baike.baidu.com/item/传输层/4329536)和[数据链路层](https://baike.baidu.com/item/数据链路层/4329290)之间，它在数据链路层提供的两个相邻端点之间的数据帧的传送功能上，进一步管理网络中的[数据通信](https://baike.baidu.com/item/数据通信/897073)，将数据设法从源端经过若干个中间[节点](https://baike.baidu.com/item/节点/865052)传送到目的端，从而向运输层提供最基本的端到端的[数据传送](https://baike.baidu.com/item/数据传送/500685)服务。主要内容有：虚电路分组交换和[数据报](https://baike.baidu.com/item/数据报)分组交换、[路由选择](https://baike.baidu.com/item/路由选择/10824858)[算法](https://baike.baidu.com/item/算法/209025)、阻塞控制方法、[X.25协议](https://baike.baidu.com/item/X.25协议)、综合业务数据网（ISDN）、[异步传输模式](https://baike.baidu.com/item/异步传输模式/511955)（ATM）及网际互连原理与实现。\n\n<!--more-->\n\n[TOC]\n\n## 网络层提供的两种服务\n\n两种服务的共同特点：网络层向上只提供简单的、无连接的、尽最大努力交付的数据报服务，不保证可靠通信\n\n1. 虚电路：保证可靠通信，必须建立连接\n2. 数据报：尽最大努力发送，不保证可靠通信\n\n## 网际协议IP\n\n与IP配套使用的三个协议： \n\n1. 地址解析协议ARP\n2. 网际控制报文协议ICMP\n3. 网际组管理协议IGMP\n\n### 虚拟互连网络\n\n虚拟互联网络：逻辑互连的网络，可以由多种异构网络互连组成，在网络层上看起来像一个统一的网络\n\n中间设备：用来将网络互相连接\n\n1. 物理层的中间设备：转发器\n2. 数据链路层的中间设备：网桥\n3. 网络层的中间设备：路由器\n4. 网络层以上的中间设备：网关\n\n### 分类的IP地址\n\n*A、B、C类地址都是单播地址 D类地址用于多播*\n\n将IP地址划分为若干个固定类，每一类地址都由网络号(net-id)和主机号(host-id)构成一个IP地址在整个互联网范围内是唯一的。\n\nIP地址的编址方法：\n\n1. 分类的IP地址：是最基本的编址方法\n2. 子网的划分：对最基本编址方法的改进\n3. 构成超网：比较新的无分类编址方法\n\n**IP地址的重要特点：**\n\n1. 每一个IP地址都由网络号和主机号两部分组成，是一种分等级的地址结构\n2. 实际上IP地址是标志一个主机或(路由器)和一条链路的接口\n3. 用转发器或网桥连接起来的若干给局域网仍为一个网络，因为这些局域网都具有同样的网络号net-id\n4. 所有分配到网络号的网络都是平等的\n\n**网络上的IP地址：**\n\n1. 同一局域网上的各IP地址的网络号都是相同的\n2. 用网桥互连的网段仍是一个局域网，只有一个网络号\n3. 一个路由器有多个接口，每个接口对应的网络号不同\n4. 两路由器直接相连时，可以不给两端接口分配IP，这样的特殊网络也叫无编号网络或无名网络\n\n### IP地址与硬件地址\n\nIP地址与硬件地址区别：从层次看，硬件地址或物理地址是数据链路层和物理层使用的地址，IP地址是网络层和以上各层使用的地址，是一种逻辑地址\n\n![IP地址与硬件地址](https://raw.githubusercontent.com/5522MIKE/PicGo/master/md/20200602141739.jpg)\n\n### 地址解析协议ARP\n\nIP地址与MAC地址：源IP地址和目的IP地址始终不变；而源MAC地址和目的MAC地址在每条链路上都要变化            \n\n作用：从网络层使用的IP地址，解析出在数据链路层使用的硬件地址\n\n工作方式：每个主机里都设有一个ARP高速缓存，里面有所在局域网上各主机和路由器的IP地址到硬件地址的映射表，且这个映射表经常动态更新\n\n生存时间：ARP高速缓存中每条映射都只存在一段时间，超过时间后就被删除\n\n*特点：\n\nARP协议只解决同一局域网上IP地址和硬件地址映射问题，不在同一局域网则无法解决 \nARP工作过程对用户来说是透明的\n\n四种使用ARP的典型情况：\n\n1. 发送方是主机，要把IP数据报发送到本网络上的一个主机，这时ARP找到目的主机的硬件地址\n2. 发送方是主机，要把IP数据报发送到另一个网络上的一个主机，这时ARP找到本网络上的一个路由器的硬件地址，剩下的工作由这个路由器完成\n3. 发送方是路由器，要把IP数据报发送到本网络上的一个主机，这时ARP找到目的主机的硬\n4. 地址发送方是路由器，要把IP数据报发送到另一个网络上的主机，这时ARP找到本网络上的一个路由器的硬件地址，剩下的工作由这个路由器完成\n\n### IP数据报格式\n\n略\n\n### IP层转发分组的流程\n\n略\n\n## 划分子网和构造超网\n\n### 划分子网\n\n划分子网的理由：两级IP地址的问题：\n\n- IP地址空间利用率有时很低  \n- 给每个屋里网络分配一个网络号会使路由表变得很大，因此是网络性能变坏  \n- 两级IP地址不够灵活\n\n划分子网的基本思路：借用主机号若干位作为子网地址\n\n划分子网后的IP地址：| 网络号 | (子网) | 主机号 |\n\n子网掩码：\n\n  作用：用来找出IP地址中的子网部分，长度为32位，原IP中网络号和子网部分置为1，主机号部分置为0\n\n  (IP地址)and(子网掩码)=网络地址\n\n  默认子网掩码：在不进行子网划分时，也要给出子网掩码，就用默认子网掩码\n\n子网掩码是一个网络或一个子网的重要属性，路由表中的每一项还要给出该网络的子网掩码\n\n子网数：2^k-2，k表示子网号的位数，减去全0和全1，就是可用子网数，虽然现在全0和全1地址也可以使用，但不推荐\n\n子网划分方法：\n\n1. 固定长度划分：所划分的所有子网的子网掩码都是相同的，取所用最大的主机数进行划分\n2. 变长划分：根据需求灵活划分\n\n### 使用子网时的分组转发：\n\n子网划分后的路由表：包含目的网络地址、子网掩码、下一跳地址\n\n子网划分后的路由器转发分组算法：\n\n略\n\n### 无分类编址CIDR(构造超网)：\n\n概述：它最最主要的一点是消除了A,B,C类地址和划分子网的概念.它重新将IP地址划分为两个部分即,”网络前缀”和”主机号”.注意这里的网络前缀再也没有位数的限制,即没有A,B,C类之分\n\nCIDR的主要特点：\n\n1. 消除了传统A、B、C类地址及划分子网的概念，重新将IP地址划分为两个部分即,”网络前缀”和”主机号”.注意这里的网络前缀再也没有位数的限制,即没有A,B,C类之分\n2. 把网络前缀相同的连续IP地址组成一个CIDR地址块，只要知道任一个地址，就可以知道这个地址块的起始地址和最大地址以及地址数\n\n格式：使用网络前缀代替网络号和子网号，使IP地址变回两级格式\n\n斜线表示法：/24表示子网掩码前24位为1，即网络前缀的位数\n\nCIDR地址块：把网络前缀都相同的连续IP地址组成CIDR地址块\n\n路由聚合：一个CIDR地址块能表示很多地址，这种地址的聚合称为路由聚合，也称为构成超网；有利于减少路由器之间的路由选择信息的交换，从而提高整个互联网的性\n\n最长前缀匹配：\n\n- 用收到的目的地址与路由表中的每条掩码依次相与，取最长前缀匹配项的地址作为下一跳\n- 因为前缀越长，其地址块就越小，因而路由就越具体\n\n二叉线索树：\n\n将路由表中各IP地址构成一个01字典树，也称为二叉线索树，能极大优化路由表匹配过程\n\n## 网际控制报文协议ICMP\n\n课堂问题：为什么ICMP要和IP一起发送？\n\nA:需要转发\n\n作用：ICMP允许主机或路由器报告差错和提供有关异常情况的报告\n\n### 报文种类：\n\n略\n\n### ICMP的应用：\n\n- PING： PING即Packet InterNet Groper，用于探测两台主机间是否连通，源主机向目标主机发送ICMP的回送请求报文（封装在IP数据报中），目标主机若接收到该报文则返回回送回答报文\n\n- 路由探测： 路由探测即源主机向目标主机发送无法交付的UDP数据报（封装于IP数据报，若目标主机接收到该数据报，则会返回ICMP终点不可达报文），第一次发送时将IP数据报的生存时间设为1，这样一来第一个路由器接收到后将生存时间-1就会直接判断该IP分组需要丢弃，并返回ICMP时间超过报文，源主机接下来发送第二个IP数据报（依然为不可交付UDP数据报），此次将生存时间设为2……以此类推，直至接收到ICMP终点不可达报文，或生存时间达到上限为止。\n\n## 互联网的路由选择协议\n\n### 路由选择协议基本概念\n\n分层次的路由选择协议：\n\n互联网采用分层次的路由选择协议，自适应的(动态的)、分布式路由选择协议\n\n*自治系统AS：\n\n在单一技术管理下的一组路由器，在AS内部使用内部网关协议，AS之间使用外部网关协议\n\n路由选择协议分类：\n\n1. 内部网光协议IGP：在一个自治系统内部使用。如RIP、OSPF协议\n2. 外部网光协议EGP：在不同自治系统之间使用。如BGP协议\n\n### 内部网关协议RIP\n\n略\n\n### OSPF协议\n\n略\n\n### 外部网关协议EGP\n\n略\n\n### 路由器的构成\n\n略\n\n*补充内容：*\n\n## IPv6\n\n主要变化：\n\n- 更大的地址空间：将地址从32位增大到128位\n- 扩展的地址层次结构\n- 灵活的首部格式：定义了很多可选的扩展首部\n- 改进的选项：允许数据报包含有选项的控制信息，其选项放在有效载荷中\n- 允许协议继续扩充\n- 支持即插即用：自动配置，不需要使用DHCP\n- 支持资源的预分配\n- 首部改为8字节对齐\n\n## VPN&NAT\n\n### VPN\n\n概述：用于机构内部的通信，而不是用于和网络外非本机构的主机通信，但没有真正使用通信专线，VPN只是在效果上和真正的专用网一样\n\nVPN的构建：\n\n所有通过互联网传送的数据都必须加密，要构建VPN必须为它的每一个场所配置专门的硬件和软件，使每一个场所的VPN系统都知道其他场所的地址\n\n### 网络地址转换NAT\n\n要在路由器上安装NAT软件，装有NAT软件的路由器称为NAT路由器，它至少有一个有效的外部全球IP地址，所有使用本地地址的主机在和外界通信时，都要在NAT路由器上将其本地地址转换为全球IP地址，才能和互联网连接","tags":["技术探究"],"categories":["技术"]},{"title":"浅谈pathinfo","url":"/2020/05/06/pathinfo/","content":"\n在学习`thinkPHP`的过程中使用控制器进行跳转，结果会定向到`404`页面。URL是正确的，形如`http://localhost/index.php/index/index/flower/a/2/b/3`。起先我认为是我代码的问题，结果我发现别人的代码可以运行。我意识到有可能是我的服务器的问题或者和`Url Router`有关。这件事突然就变得有意思了起来，我决定系统的去思考一下问题在哪并解决它。\n\n<!--more-->\n\n### 先看看设计模式\n\n`thinkPHP`是很出名的`MVC`框架，`Model - View - Controller`的设计模式使得我所有的交互都首先得通过`Controller`，再由`Controller`去进行其它的交互。我检查了我那简单至极的`Controller`没有发现错误。和`Controller`相关联的`.php`文件也没有问题。然后我发现我们老师布置的作业框架并不是完全的`MVC`设计模式...这个暂且不谈。那么既然代码没有问题，就是环境配置的问题了。\n\n### `thinkPHP`是如何通过`Url Router`跳转的\n\n在`thinkPHP`进行常规`url`解析之前，先检测路由，如果发现有路由规则匹配当前的`pathinfo`，那么`URL`解析则交给路由处理。\n\n路由规则是由多条 rule=>router 规则组成的数组。\n\n路由处理过程大概如下：\n\n1.遍历路由规则，与当前`pathinfo`字符串进行匹配，如果合法，则从`pathinfo`中取出所需要的字符串。\n\n2.路由中每条规则对应一个`router`，`router`中指定对应的模块以及方法，模块和方法可以用第1步中匹配到的字符串进行动态替代。\n\n3.将剩余的参数都解析并写入到`$_GET`中。\n\n`pathinfo`模式：\n\n```\nhttp://域名/项目名/入口文件/模块名/方法名/键1/值1/键2/值2\n```\n\n\n这也就是说，我如果想用`thinkPHP`进行`URL`跳转，那么我需要开启有关`pathinfo`的配置。结果经过查询，`apache`是默认开启`pathinfo`的，所以老师才得以直接使用而不需要相关配置。我陷入了误区，我以为我使用的是`apache`。结果实质上我将项目导入`PHPstorm`后，浏览项目时使用的是`PHP`直接提供的默认端口号为`63342`的内置服务器。真的是粗心犯错。。我把web 服务器换为`apache`后就可以运行了。\n\n### 后记\n\n解决了问题后，为了更加深入的了解`URL`解析流程，去看了[`ThinkPHP/Lib/Core/Dispatcher.class.php`](https://github.com/top-think/thinkphp/blob/master/ThinkPHP/Library/Think/Dispatcher.class.php)核心类。在这里贴一段：\n\n```php\n// 分析PATHINFO信息\n        if (!isset($_SERVER['PATH_INFO'])) {\n            $types = explode(',', C('URL_PATHINFO_FETCH'));\n            foreach ($types as $type) {\n                if (0 === strpos($type, ':')) {\n                    // 支持函数判断\n                    $_SERVER['PATH_INFO'] = call_user_func(substr($type, 1));\n                    break;\n                } elseif (!empty($_SERVER[$type])) {\n                    $_SERVER['PATH_INFO'] = (0 === strpos($_SERVER[$type], $_SERVER['SCRIPT_NAME'])) ?\n                        substr($_SERVER[$type], strlen($_SERVER['SCRIPT_NAME'])) : $_SERVER[$type];\n                    break;\n                }\n            }\n        }\n\n```\n\n看完后两个感受：\n\n1. 中午注释真舒服\n2. `PHP`果然没有好好学，很多语法都要现查\n\n### 参考：\n\n[ThinkPHP中URL解析原理，以及URL路由使用教程](https://blog.csdn.net/zstxt1989/article/details/9310121)","tags":["技术探究","思考"],"categories":["技术"]},{"title":"读书和写作","url":"/2020/04/20/读书和写作/","content":"\n高中读了很多书，大学没怎么读书，反而是看了很多小说，打了很多游戏。\n\n最近突然惊觉，应该继续读书了。同时和很优秀的几位朋友和前辈聊了一下，决定要开始认真的写作了。用写作来作为知识和思考的积累方式。\n\n<!--more-->\n\n看啥书？\n\n看专业书籍，文学书籍，以及引人思考的blog\n\n写什么？\n\n写所有想写的，越多越好。同时一周保持一篇有质量的技术文档。\n\n怎么写？\n\n真不知道怎么写。重新看on writing吧。。\n\n如何进行分发，如何和人进行讨论？\n\n分发和讨论先自己去找认识的人吧。\n\n// TODO","tags":["思考"],"categories":["读书"]},{"title":"考研与未来的方向","url":"/2020/04/20/考研与未来的方向/","content":"\n由于这一场超乎想象的疫情，我大学以来最重要的一个学期，一个思考的转折点在家中度过。在家开学4周之后，随着许多的朋友，学长开始走向新的人生方向，或是努力保研，或者准备考研，亦或者是开始寻找实习。我也开始真正意义上开始去寻找，去决定我未来两年的方向。\n\n<!--more-->\n\n其实对于我来说只有两个方向可以去选择：考研，工作。当然这是十分笼统的方向，考什么专业的研，做什么方向，考研的目的是什么？是以找开发工作为导向的考研，还是以进一步进军学术界为方向的考研？工作的选择就更多了。去做一个什么方向的工作，去什么样的岗位。可以接受什么样的薪资和工作强度？在什么城市？选择一个什么样的行业？真是复杂。本以为大学比高中长，结果却是比高中短。短到只有一年半就必须去思考。\n\n又到了一个选择决定努力的环节了。先不聊选择，聊聊怎么努力。如果工作，那么我现在就应该以工作为导向去学点真正有用的技术了。而且要学深。如果考研，那就以考研为导向去学习，最好能在大三前就确定研究的大致方向，增加考研竞争力。还有两个通用指标：英语和算法。\n\n再看看现在的社会背景。未来一到两年整体经济发展肯定会因为疫情受到打击，就业形势肯定不会太好。同样的，随着大学的扩招和就业形势的问题，计算机会是一个持续热门的方向。考研难度也会增大。同时，我在广东，在华师。华师称不上什么好学校，但在省内还勉强是第二梯队。根据我以往的在广东省内发展的想法，考研想博得一个更好的平台就只有中大和华工两个选择。这内卷程度。。。怕了怕了。同样的，在就业方面，华师很难给我一个很好的平台。但是还是有资格去递一下下简历的。递完简历之后，当然就看个人能力了。没能力读研和工作都没得用。\n\n聊一下周围人的情况。我不止一个人对我说，要不就保研要不就工作。同样有不止一个人对我说一定要有一个研究生文凭。这要怎么选择呢？我觉得还是要看自己未来的一个发展方向。如果追求的是安逸，那么一个研究生文凭相当有用。如果追求的是突破阶级，是奋斗是赚大钱，那么可能自身的能力更重要一点。无味的三年或是两年研究生，加上一年的准备时间可能是生命的浪费。但是有几个人的能力能达到呢？就算是不考研究生多个几年又怎么样呢......\n\n我的目标是靠自己的能力在深圳快乐的活下去。因为只有这样才能真正的融入这个城市。我是爱这座新城的，我认可他的价值观，我在这长大，我熟悉他，我在这有着很多的朋友。虽然他很皮，这疫情时房子还能涨到7万就离谱。加速，都给我加速。我还是希望能在深圳生活的。之前写到过我追求相对自由（虽然那篇文章被我屏蔽了），那我应该考研还是不考呢？考吧。思考了这么久，我需要对自己有一个明确的回答了。其实我一直都知道考研才是最好的选择。我没有金钱的压力，出来工作是能赚点钱，是可以保持一个独立和自由。可是然后呢？是呀然后呢。其实我是在畏惧着考研，毕竟考不上怎么办，还有考研真的很累的呀。过了两年舒服生活的我怎么回到一个紧张的状态里去也还是一个问题。对于我这种喜欢代码，喜欢折腾的人来说，选择工作确实轻松不少。\n\n总归还是要逼自己一把，这篇文章就为我接下来两年定一个目标——考研。那写这么长干嘛。哈哈哈哈。五年后更新。（如果我还记得的话。\n\n","tags":["思考"],"categories":["随笔"]},{"title":"计网-数据链路层","url":"/2020/04/15/计网-数据链路层/","content":"\n> 数据链路层是[OSI参考模型](https://baike.baidu.com/item/OSI参考模型)中的第二层，介乎于[物理层](https://baike.baidu.com/item/物理层/4329158)和[网络层](https://baike.baidu.com/item/网络层/4329439)之间。[数据链路](https://baike.baidu.com/item/数据链路)层在[物理层](https://baike.baidu.com/item/物理层/4329158)提供的服务的基础上向[网络层](https://baike.baidu.com/item/网络层/4329439)提供服务，其最基本的服务是将源自网络层来的数据可靠地传输到相邻节点的目标机网络层。\n\n<!--more-->\n\n[TOC]\n\n## 基本概念\n\n数据链路层使用的信道：\n\n- 点对点信道：使用一对一的点对点通信方式\n- 广播信道：使用一对多的广播通信方式，过程比较复杂，需要专用的协议来协调\n\n本章**最重要**的内容是：\n\n- 数据链路层的点对点信道和广播信道的特点，以及这两种信道所使用的协议（PPP协议以及CSMA/CD协议）的特点。\n- 数据链路层的三个基本问题：封装成帧、透明传输和差错检测\n- 以太网MAC层的硬件地址\n- 适配器、转发器、集线器、网桥、以太网交换机的作用以及使用场合。\n\n## 使用点对点信道的数据链路层\n\n1. **数据链路和帧**\n\n- 链路(物理链路)：从一个结点到相邻结点的一段物理线路，中间没有任何其他的交换节点\n\n     链路是一条路径的一个组成部分：两台计算机之间的通信路径需要许多链路\n\n- 数据链路(逻辑链路)：把实现了这些通信协议的硬件和软件加到链路上，就构成了数据链路(物理线路+协议)\n\n- 网络适配器：既有硬件也包括软件，实现了通信协议，包括了数据链路层和物理层两层的功能\n\n- 规程：数据链路层中，规程等同于协议\n\n- 帧：点对点信道数据链路层的协议数据单元\n\n- 数据链路层通信时的主要步骤：\n\n    (1)结点A的数据链路层把网络层交下来的IP数据报添加首部和尾部封装成帧\n    \n    (2)结点A把封装好的帧发送给结点B的数据链路层\n    \n    (3)若结点B的数据链路层收到的帧无差错，则从收到的帧中提取IP数据报上交给网络层；否则丢弃这个帧\n\n- 特点：数据链路层不用考虑物理层如何实现，所以就相当与对等层水平传输\n\n2. **三个基本问题**\n\n- 封装成帧\n- 透明传输\n- 差错检测\n\n## 点对点协议PPP\n\n1. **PPP协议的特点**\n\n- 作用域：用户计算机和ISP通信时所使用的数据链路层协议\n\n- PP协议应满足的需求：\n\n(1)简单：对数据链路层的帧，不需要纠错、序号、流量控制，简单作为首要要求；收到帧进行CRC检验，无差错则接收，反之丢弃\n      \n(2)封装成帧：必须规定特殊的字符作为帧定界符，使接收端从收到的比特流中准确找出帧的开始和结束位置\n      \n(3)透明性：必须保证数据传输的透明性，要能解决碰巧出现和帧定界符一样的比特组合的问题\n      \n(4)多种网络层协议：必须能够在同一条物理链路上同时支持多种网络层协议的运行，如IP等；在局域网和路由器上同样如此\n\n(5)多种类型链路：必须能够在多种链路上运行\n      \n(6)差错检验：必须能够对接收端收到的帧进行检测，并立即丢弃有差错的帧\n      \n(7)检测连接状态：必须能够自动检测链路是否处于正常工作状态\n      \n(8)最大传送单元：必须对每一种类型的点对点链路设置MTU的标准默认值；促进各种实现之间的互操作性，若高层协议发送的分组数据部分超过MTU值，则丢弃并返回差错\n      \n(9)网络层地址协商：必须提供一种机制使通信的两个网络层的实体能够通过协商知道或能够配置彼此的网络层地址\n      \n(10)数据压缩协商：必须提供方法来协商使用数据压缩算法\n\n- PPP的特点：不支持多点线路，只支持点对点的链路通信，只支持全双工链路\n\n- PPP协议不需要的功能：纠错、流量控制、序号、多点线路、半双工或单工链路（只工作在点对点链路）\n\n- PPP协议的组成：\n\n(1)将IP数据报封装到串行链路的方法；PPP支持异步链路，也支持面向比特的同步链路；IP数据报在PPP帧中数据部分，收到MTU限制\n      \n(2)用来建立、配置和测试链路连接的链路控制协议LCP\n      \n(3)网络控制协议NCP，其中每一个协议支持不同的网络层协议\n\n2. **PPP协议的帧格式**\n\n![20190128231023274](https://raw.githubusercontent.com/5522MIKE/PicGo/master/md/PPP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%B8%A7%E6%A0%BC%E5%BC%8F.png)\n\n2. **PPP协议的工作状态**\n\n![20190128230546475](https://raw.githubusercontent.com/5522MIKE/PicGo/master/md/PPP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%B7%A5%E4%BD%9C%E7%8A%B6%E6%80%81.png)\n\n## 使用广播信道的数据链路层\n\n1. **局域网的数据链路层**\n\n- 局域网的特点：网络为一个单位所拥有，且地理范围和站点数目均有限\n\n- 局域网的优点：\n\n(1)具有广播功能，从一个站点可方便的访问全网；局域网上主机共享局域网上各种硬件和软件资源\n\n(2)便于系统的扩展和演变，各设备的位置可灵活调整和改变\n\n(3)提高了系统的可靠性、可用性和生存性\n\n- *局域网的拓扑结构：总线网、环形网、星形网*\n- 媒体共享技术\n- 网络协议\n- 以太网的两个标准：DIX Ethernet V2；IEEE 802.3\n- 数据链路层的两个子层\n- 适配器的作用\n\n2. *CSMA\\CD协议*\n3. *使用集线器的星形拓扑*\n4. *以太的网信道利用率*\n5. *以太网的MAC层*\n\n- MAC帧格式：\n\n![20190128230546533](https://raw.githubusercontent.com/5522MIKE/PicGo/master/md/MAC%E5%B8%A7%E6%A0%BC%E5%BC%8F.png)\n\n## 扩展的以太网\n\n**物理扩展：集线器、光纤**\n\n1. **在数据链路层扩展以太网**\n2. **虚拟局域网**\n\n## 实验部分\n\n无","tags":["技术探究"],"categories":["技术"]},{"title":"计网-物理层","url":"/2020/04/11/计网-物理层/","content":"\n> **物理层**（或称物理层，Physical Layer）是[计算机网络](https://baike.baidu.com/item/计算机网络)[OSI模型](https://baike.baidu.com/item/OSI模型)中最低的一层。物理层规定:为传输数据所需要的物理链路创建、维持、拆除，而提供具有机械的，电子的，功能的和规范的特性。简单的说，物理层确保原始的[数据](https://baike.baidu.com/item/数据/5947370)可在各种物理媒体上传输。[局域网](https://baike.baidu.com/item/局域网/98626)与[广域网](https://baike.baidu.com/item/广域网/422004)皆属第1、2层。\n\n<!--more-->\n\n[TOC]\n\n## 基本概念\n\n1. 物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。\n\n2. 物理层的作用是要尽可能地屏蔽掉不同传输媒体和通信手段的差异。\n\n3. 物理层的主要任务:确定与传输媒体的接口的一些特性：**机械特性**、**电气特性**、**功能特性**和**过程特性**。\n\n   - 机械特性：接口所用接线器的形状和尺寸、引脚数目和排列、固定和锁定装置等\n\n   - 电气特性：接口电路的各条线上出现的电压范围\n\n   - 功能特性：某条线上出现某一电平电压的意义\n\n   - 过程特性：对于不同功能的各种可能事件的出现顺序\n\n## 数据通信的基础知识\n\n1. 数据通信系统的模型\n\n   数据通信系统可以划分为三大部分：**源系统**（或发送端、发送方）、**传输系统**（或传输网络）、**目的系统**（或接收端、接收方）\n\n   ![数据通信模型](https://raw.githubusercontent.com/5522MIKE/PicGo/master/md/%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A8%A1%E5%9E%8B.jpg)\n\n2. 有关信道的几个基本概念\n\n   信道：表示向某一个方向传送信息的媒体\n   \n   - 单向通信\n   - 双向交替通信\n   - 双向同时通信\n   \n   基带信号：来自信源的信号；如计算机输出的代表文字或图像的数据信号都是基带信号\n   \n   调制分类：\n   \n   - 基带调制(编码)：仅对基带信号的波形进行变换，使其能与信道特性相适应，变换后的信号仍是基带信号\n   \n   - 带通调制：使用载波进行调制，把基带信号的频率范围移到较高频段，并转换为模拟信号，变换后的信号称为带通信号\n   \n   常用的编码方式：\n   \n   - 不归零制\n   - 归零制\n   - 曼切斯特编码\n   - 差分曼切斯特编码\n   \n   基本的带通调制方法：\n   \n   - 调幅（AM）\n   - 调频（FM）\n   - 调相（PM）\n   - 特殊：正交振幅调制QAM\n   \n3. 信道的极限容量\n\n   限制码元在信道上传输速率的因素：\n\n   - 信道能够通过的频率范围    （码间串扰，奈氏准则）\n   - 信噪比    （香农公式）\n\n## 物理层下面的传输媒体\n\n**传输媒体是数据传输系统中在发送器和接收器之间的物理通路**\n\n分类：\n\n- 引导型：双绞线、同轴电缆、光纤\n- 非引导型：电磁波无线传输\n\n## 信道复用技术\n\n**复用：允许用户使用一个共享的信道进行通信，降低成本，提高利用率**\n\n- 频分复用\n- 时分复用\n- 统计时分复用\n- 波分复用WDM\n- **码分复用CDM**\n\n## 数字传输系统\n\n早期缺点：\n\n- 速率标准不统一\n- 不是同步传输\n\n现代的传输网络的传输媒体：光纤\n\n同步光纤网(SONET)：各级时钟都来自一个非常精确的主时钟，为光纤传输系统定义了同步传输的线路速率等级结构\n\n同步数字系列(SDH)：由SONET为基础发展的国际标准\n\n## 宽带接入技术\n\nADSL技术：非对称数字用户线，将原有的模拟电话线进行改造，使其能够承载宽带业务，将0-4k的低端频谱留给电话使用，将剩余部分给宽带使用，其中上行带宽小于下行带宽。\t第二代ADSL：得到更高的数据率，采用无缝速率自适应技术，可在运营中不中断通信和不产生误码的情况下，自适应的调整数据率\n\n光纤同轴混合网(HFC)：是目前覆盖面较广的有线电视网，采用模拟技术，频分复用，主干部分使用光纤，入户部分使用同轴电缆\n\nFTTx技术：是一种实现宽带居民接入网的方案，代表多种宽带光纤接入方式\n\n## 实验部分\n\n实验过程中发生了一些问题，后来发现是对原理不熟悉导致的。比如第一次配置vtp的时候没有配置trunk。一个警醒，在实验前一定要搞定所有的流程概念。","tags":["技术探究"],"categories":["技术"]},{"title":"搭建一个自己的博客","url":"/2020/04/03/开始搭建你的第一个博客/","content":"本文面向无基础学生。\n\n博客为静态博客，无需费用。\n\n使用的工具和框架：\nGitHub Pages + hexo\n\n<!--more-->\n\n## 为什么要搭建个人博客\n\n+ 将自己的思考和学习经历记录下来作为一个知识沉淀的平台\n+ 在搭建博客和升级博客的过程中学习技术\n+ 展示你自己，并且可以作为他人了解你的渠道\n+ 成为社区的一份子，帮助到他人。博客中记录的bug和经历可以让更多的人少走弯路。\n\n优秀的个人博客推荐：\n+ [轮子哥/vczh](http://cppblog.com/vczh)\n+ [鳥哥的 Linux 私房菜](http://linux.vbird.org/)\n+ [王垠](http://www.yinwang.org/)\n+ [阮一峰的个人网站](http://www.ruanyifeng.com/home.html)\n\n## 使用GitHub page + hexo快速搭建\n\n### 环境准备\n安装[Node.js](https://nodejs.org/zh-cn/)和[Git](https://git-scm.com/)并注册[GitHub](https://github.com/)\n\n安装成功检验：\n\n在命令行执行下列命令：\n```bash\n$ git --version\ngit version 2.9.0.windows.1\n$ node --version\nv10.15.3\n$ npm --version\n6.4.1\n```\n\n\n### 安装Hexo\n在命令行执行下列命令：\n```bash\n$ npm install -g hexo-cli\t# -g 代表着全局安装\n```\n\n完成后建立你的个人博客：\n```bash\n$ hexo init blogName\n$ cd blogName\n$ npm install\n```\n\n博客文件夹的目录如下：\n```bash\n├───.git\n├───scaffolds\t# 博客的模板文件夹\n├───source\t# 资源文件夹\n│   └───_posts\t# 你的博客源文件(.md)\n└───themes\t# 主题文件夹\n    └───landscape\t# 默认主题\n├───.gitignore\n├───.gitmodules\n├───_config.yml\t# 博客的配置文件\n├───package.json # 项目管理文件\n```\n\n\n### 创建你的第一篇博文\n新建一篇博文：\n```bash\n$ hexo new '文章标题'\n```\n\n在 ` /source/_posts `文件夹下找到你的博文，使用Markdown编辑器打开并编辑。\n\n推荐使用Typora进行编辑。\n在[Markdown Guide](https://www.markdownguide.org/basic-syntax/)或者[菜鸟教程](https://www.runoob.com/markdown/md-tutorial.html)学习Markdown语法。\n\n保存后运行：\n```bash\n$ hexo generate # 生成静态文件，可简写为 hexo g\n$ hexo server # 启动服务器。默认情况下，访问网址为：`http://localhost:4000/`。可以简写为 hexo s\n```\n\n此时已经可以在`public`文件夹下看到完整的静态文件。\n在浏览器中输入`http://localhost:4000/`就可以看到预览效果了。\n\n\n### 部署到GitHub Pages\n\n1. 在GitHub创建一个名为`username.github.io`的新仓库，其中`username`是您在GitHub上的用户名（或组织名称）。\n! 如果仓库的第一部分与您的用户名不完全匹配，则它将不起作用，因此请确保正确无误。\n\n2. 转到要存储项目的文件夹，然后克隆新的仓库：\n```bash\n$ git clone https://github.com/username/username.github.io\n```\n\n3. 将之前生成的`public`文件夹下的文件拷贝到本地仓库中。再运行：\n```bash\n$ git add --all\n$ git commit -m \"Initial commit\"\n$ git push -u origin master\n```\n\n4. 等待一段时间你就可以启动浏览器并转到`https://username.github.io`你就可以看到自己的博客啦！\n\n// 将博客部署到GitHub还有其他方法，比如可以使用`hexo deploy`。这个就请自行学习探索啦。\n\n### 了解并丰富你的博客\n\n以下是一些进阶网站：\n+ [超详细Hexo+Github Page搭建技术博客教程](https://segmentfault.com/a/1190000017986794)\n+ [hexo官网](https://hexo.io/zh-cn/)\n+ [GitHub Pages](https://pages.github.com/)\n\n## 进阶博客搭建\n\n想必很多同学在完成简单的静态博客搭建后都想尝试更加绚丽，互动性和自定义更强的博客。\n首先你需要购买一个域名，拥有一个服务器。\n使用[WordPress](https://zh-cn.wordpress.com/)可以快速搭建一个动态博客。\n如果你不仅仅满足于使用框架和平台，那么你可能需要去了解并学习一些更加深入的东西，前端可以用Vue或者React，后端用python的Django,Flask框架实现快速开发个人博客。\n\n","tags":["解决方案"],"categories":["技术"]},{"title":"我的win环境备份","url":"/2020/03/23/我的win环境备份/","content":"\n最近可能要重装电脑或者购置新的机器，故记录现在我需要的一台win系统的电脑应该需要什么样的环境。\n\n<!--more-->\n\n**装个linux它不香吗**\n\n## 环境\n### 语言类\nMinGW：Windows下的基于GCC 程序开发环境  \nPHP  \nJAVA  \nNode.js  \nPython\n\n### 工具类\n\nGit：版本管理工具，必用  \nTerminal：终端，别用cmd了。   \nWSL2：win下的Linux子系统。在某些环境下很好用，比如搭配vscode写代码。  \n\n### 数据库\n\nmysql  \nsqlserver\n\n### 服务器\napache  \nnginx\n\n## 日常软件\n火绒：十分简洁的安全软件  \neverything：电脑文件查找软件，可以极快的找到文件  \n7-zip/Bandzip：优秀的压缩工具  \nInternet Download Manager：下载神器  \n搜狗输入法  \nsumatraPDF：PDF阅读器  \noffice：特别提一下visio，绘图软件  \nCAJViewer：文献阅读器，用来读知网论文很方便  \n\n## 专业工具\n### 编程类\nJetBrain全家桶(toolbox，PHPstorm，DataGrip，Clion，IDEA 等)：IDE世界里最强大的全家桶。**学生可以用.edu邮箱免费使用**  \nCodeBlocks：优秀且简单易用的C/C++IDE  \nEclipse：上古神器，一般用来写JAVA。实则干啥都能 //实则是学校要用  \nVSCode：一个介于IDE和编辑器的神器。熟练使用插件和配置可以达到**awesome**的效果。  强力推荐  \nXshell：SSH客户端。我一般用来连接云服务器  \nVMware：虚拟机软件  \n\n### 工程类\nCisco Packet Tracer：网络仿真软件，学计网时候用的  \nWireshark：网络封包分析软件  \nPostman: 接口测试  \nAxure：原型设计工具，可以学生认证  \nXMind：思维导图  \n腾讯会议：用来小组讨论十分方便和稳定  \n\n### 数学、论文类\nMATLAB：数学软件。这个也有很多学校买了，可以去学校软件站看看  \nSPSS：数据分析软件  \nTypora：神仙编辑器，最好的markdown编辑器。本文就是用它写的  \nLaTeX：排版系统，用来写论文非常好  \n\n### 其他\nrufus：引导盘制作工具  \nAdobe全家桶(PS，Au，Pr 等)  \nShadowsocksR/v2rayN：误  \n\n## 娱乐软件\nChrome  \nFirefox  \nEdge  \nTim/QQ  \n微信  \n网易云音乐  \n百度网盘  \nPotPlayer：极强大的播放器  \nSteam(Wallpaper Engine,Fences)  \nWeGame  \nOrigin  \n\n## 一些简单的搭配应用场景\n// TODO 待更  \nvscode + wsl/wsl2","tags":["技术"],"categories":["技术"]},{"title":"美赛","url":"/2020/02/12/美赛/","content":"国赛讲究实力，美赛讲究创新。   \n\n//本文是为了数学建模美赛做赛前准备\n\n<!--more-->\n\n时间：北京时间3月6日上午6时至3月10日上午9时\n流程：\n\n1. 3月6日上午6时前往官网查看题目(http://www.comap.com/undergraduate/contests/mcm)\n2. 3月10日上午9时前提交论文\n- 1 提交论文电子版：\n每队必须提交一份论文电子版，邮箱地址：solutions@comap.com。同时提交指导教师一份。截止日期：北京时间2020年3月10日上午9:00。提交的论文不允许有任何增加或修改，否则将被认为违规而取消比赛资格。不允许重复发送，发送之前建议由指导教师定稿。（由于临近比赛结束时网络拥堵，发送邮件可能有延迟，建议7点前完成发送）\n\n- 2 邮件主题为COMAP+队号。例如：COMAP2020449\n\n- 3 用队号作为邮件附件的名称。\n\n- 4 组委会只接受PDF或WORD文件（建议采用ＰＤＦ格式，公式不容易乱）。不包括控制页，程序或软件，因为不会被用在评审过程中（程序代码不是必须的，只要论文就行）。学生、老师或学校名称不应出现在论文的任何部分。摘要页（Summary Sheet）应为论文的第一页。注意：附件必须小于17MB。禁止使用云服务。\n\n- 5 发送论文后，再次登录美赛官网，点击Submit Final Solution Paper。\n\n\n根据时间顺序分为以下几个部分：\n1. 赛前学习\n- 1 文献和数据网站\n[Google Scholar](https://scholar.google.com/)(需要梯子)  \n[阿里开发数据库](https://tianchi.aliyun.com/dataset/?spm=5176.12281905.0.0.358b5699IjonJQ)  \n[cnki](https://www.cnki.net/)  \n[nasa](https://sedac.ciesin.columbia.edu/)  \n[science](https://science.sciencemag.org/)  \n[deepdyve](https://www.deepdyve.com/)  \n- 2 软件\n编程工具：MATLAB   \n统计建模：SPSS  \n写作：LaTex/word  \n// TODO  \n流程图制作：ppt、visio、亿图  \n插图制作：PS  \n团队协作：线上交流+语音+在线文档  \n\n- 3 数学建模\t// TODO\n\t\t模型储备\n- 4 题型分析及选择(由于我们只可能在3月参加，故只分析三道)\n  \n```bash\nMCM Problem B\nMCM Problem C\nICM Problem F（推荐且论文页数不超过20）\n```\n\n- 5 论文规范及书写安排 // TODO\n\n2. 模拟比赛\n     // TODO\n\n3. 赛前准备\n       (1) 物资准备：包括但不限于 软件准备 比赛通信 资料网站准备 邮件准备  \n       (2) 分工：模拟比赛后划分  \n       (3) 时间安排: 模拟比赛后安排  \n\n\n附录：\n\n2017年国赛B题分析：\n\n以下分析基于一等奖的两篇优秀论文。\n\n总述：选择这一题的主要原因是因为这道题较为简单，而且年份较近具有一定的代表性。另外就是中文好理解。\n\n以下分析只包含个人感受和一定的主观思考。\n\n优秀论文1：数学建模能力极强。其他方面的能力并不算突出，编程水平较弱。\n\n优秀论文2：技术水平整体高。包括建模、编程水平还有写作水平。写作格式值得借鉴。\n\n两篇优秀论文的共通点是数学建模能力都很强，而且均体现了各自对题目的思考，并成功的将思考转化为数学模型。（论文1在问题2处引入了吸引力因子，论文2标黑的都是自己引入的参数或者重点）两篇文章的正文部分均在20页左右（17,23）。我们写作时需要注意美赛题目对页数的要求。\n\n这里额外说一下关于数学模型的使用。在论文1讨论问题4时，明确提出套用了定价模型的两个公式。问题2仿照库伦定律进行了量化，问题3使用了K-means聚类算法。论文2使用ISODATA算法分析问题1，问题2使用位势函数法。较为专业的地方两篇论文都参考或者使用或参考了成熟的数学模型。\n\n简单提一下我个人认为的要点：\n\n1. 分析问题和初步的解决思路(这里需要大量的建模知识和信息获取能力)\n\n2. 细化思路并探索可行性（难点突破和时间权衡）\n\n3. 建立数学模型（论文和成熟模型的查找及化用）\n4. 编程和写作（协同方案）","tags":["技术探究"],"categories":["技术","思考"]},{"title":"当我谈跑步时，我在谈些什么","url":"/2019/12/22/run/","content":"![run](/img/run.jpg)\n<!--more-->\n这个学期我跑了很多次步。有记录的超过2.5公里的就有34次。所以虽然我在长胖，可我还是感觉我的身体更加“轻盈”了哈哈哈。可以说这是我人生中第一次长时间的坚持跑步  //大概算长时间吧。\n而且打算坚持一下。于是想找一个方法坚持下去。\n\n我很早就知道村上春树这个人，大概是在初中。我高中很喜欢日本文学，在学校图书馆借了很多日本的书看，其中最多的就是村上先生的书。我喜欢他的那种看似有些冷淡却始终热爱生活的文字。于是这次我还是选择去看看他的书《当我谈跑步时，我在谈些什么》。\n\n当我在跑步时，我在听歌。我不停的听歌。音乐给我力量。甚至在最后的冲刺时，我会切到一首激昂的歌才开始用尽全力向前跑。这真是非常畅快的体验。\n\n","tags":["随笔","思考"],"categories":["读书"]},{"title":"小偷家族","url":"/2019/12/07/thief/","content":"![小偷家族](/img/thief.jpg)\n<!--more-->\n世界上真的只有一种病 是穷病吗？\n不是的。\n这个世界还有一种病叫 缺爱。\n真是一部很压抑又很温暖的电影。\n看完了\n不知道为什么想到了东野的嫌疑人x的献身，石神几欲呕出灵魂。而在小偷家族中，一切归于平静。\n所有的一切都被社会和时间慢慢的抹去。\n当这一种色彩渐渐消失之后，\n这六个毫无血缘关系的人，\n他们的心还在一切。\n因为什么？\n或许就像影片中的父亲说的那样。\n是爱将这个家族联系在一起。\n\n小偷家族\n他们中很多人世第三只手，\n他们全都有两颗心。\n一个留给自己\n一个分享给别人。\n他们在路上拾起别人丢弃的心。\n\n到底是什么导致了这样的家族出现呢？\n很多很多原因，\n很多我现在根本不能完全理解和领会的东西。\n不过这个家族在被发现后，\n至少社会给了他们最低的保障。\n我们能保证我们的社会有那个兜底的网吗？\n让失足的人不会就此沉沦，\n让沉沦的人不会跌下深渊。\n我们有这种爱吗？\n这种爱又是什么爱呢？\n不知道。\n我真的搞得懂这部电影在说什么吗？\n不知道。\n不知道多少年后我会重新再回来看一遍他。\n希望那时我能回答几个知道。\n\n","tags":["随笔","思考"],"categories":["随笔"]},{"title":"Git和GitHub入门","url":"/2019/12/03/Git和GitHub入门指南/","content":"\n*经过jl大佬和hy大佬的指导后重新编写*\n\n> 放GitHublogo章鱼猫的图片来作为引入\n\n*what*\n### Git和GitHub是什么\n\n**Git** (/ɡɪt/) is a distributed version-control system for tracking changes in source code during software development.  --wikipedia\n**GIT**是一个分布式版本控制系统用于跟踪的变化系统的源代码中的软件开发。--维基百科\n\n**GitHub** is an American company that provides hosting for software development. Github includes version control using Git, which allows software projects to keep track of all versions and revert to previous versions if necessary.  --wikipedia\n**GitHub**是一家美国公司，为软件开发提供托管。GitHub包含使用Git进行的版本控制，该版本控制允许软件项目跟踪所有版本，并在必要时还原为以前的版本。--维基百科\n\n**用人话说Git是啥**\nGit是一种分布式版本控制系统。但它的核心其实是数据库。Git把我们的每一次提交记录到数据库中。我们可以通过对数据库进行查询来了解并回溯每一次提交，这就实现了版本控制。然后我们可以选择将这个数据库完整的克隆到另一台服务器上，这就实现了分布式。\n\n<!--more-->\n\n### Git的工作流程\n\nGit将我们的每一次提交放到工作目录的缓存空间，完成保存。然后等你想提交到远程仓库的时候再从缓存区里提交出去。同样的，你也可以从远程仓库将文件下载回工作目录。\n\n![git-workflow1](/img/git-workflow1.png)\n\n### 啥是分布式版本控制系统(Distributed Version Control)\n\n说到分布式版本控制系统就不得不提到集中式版本控制系统，他们最大的差别在于分布式的仓库可以有很多份。其实这是一个去中心化的概念。在集中式版本控制系统中，拥有唯一的中心也就是我们常说的服务器。中央服务器是一切的核心，储存着所有的数据。而分布式版本控制则是一个去中心，或者说是多中心的系统。每一个开发者的本地仓库都拥有着全部的数据。 \"push\" \"pull\" 操作则是为了让所有的仓库数据统一而已。\n\n\n![distributed system](/img/distributed.png)\n\n### Git VS SVN\n\n|  \t\t| 集中式（SVN）| 分布式（Git）|\n|:----|:---:|:---:|\n|有无中央服务器|有。开发者脱离服务器几乎无法工作|无。开发者有本地仓库|\n|分支操作|创建分支则所有人都有此分支|分支操作不影响其他人|\n|提交|直接提交到中央版本库|首先提交到本地缓存区，执行push操作才提交到版本库|\n|图释|<img src=\"/img/svn.jpg\" width=\"50%\"/>|<img src=\"/img/git.jpg\" width=\"50%\"/>|\n\n*what*\n> // 有一说一git/github的功能详细并没有做,还是沿用了原来的简易版本\n\n### 我们用Git和GitHub来干什么\n\n+ 代码托管\t//不解释\n+ 项目管理\t//如，版本控制、协作编程\n+ 资源备份\t//如，托管编程环境、备份核心代码\n+ 托管静态网页\t//如，GitHub Page\n+ 个人简历\t//你可以在GitHub上展示你自己\n+ 查找资料\t//GitHub可能是全世界程序方面资料最多的地方\n+ 交朋友\t//全球最大的同性交友平台\n+ 资讯来源\t//GitHub热榜！比知乎更有料，比微博更劲爆\n\n*how*\n\n### Git的安装和使用\n\n#### [安装](https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%AE%89%E8%A3%85-Git)\n\n[点击此处进入官方安装教程](https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%AE%89%E8%A3%85-Git)\n\n#### 使用\n让我们先新建一个仓库（文件夹），进入文件夹并打开Git Bash。\n执行\n\n```bash\n$ git init\n```\n接下来你可以执行如下命令以创建一个本地仓库的克隆版本：\n```bash\n$ git clone /path/to/repository\n```\n如果是远端服务器上的仓库，你的命令会是这个样子：\n```bash\n$ git clone username@host:/path/to/repository\n```\n搭建好仓库后，如果你有所改动可以把它添加到缓存区，使用如下命令：\n```bash\n$ git add <filename>\n$ git add *\t\t//将所有的改动都添加\n```\n最后使用如下命令以实际提交改动：\n```bash\n$ git commit -m \"代码提交信息\"\n```\n现在，你的改动已经提交到了 HEAD，但是还没到你的远端仓库。\n执行如下命令以将这些改动提交到远端仓库：\n```bash\n$ git push origin master\t//可以把 master 换成你想要推送的任何分支。\n```\n**注意事项**\n\n+ git commit 命令一定要添加描述，否则会无法成功运行\n\n\n*本段参考自[https://www.bootcss.com/p/git-guide](https://www.bootcss.com/p/git-guide/)/*\n*想要深入了解GIt的同学可以前去参考*\n\n\n> // Git命令太多，基本命令已经在上文展示故取消Git命令大全板块\n> // 使用git中常见的问题和注意事项过于杂乱，故只提一点\n","tags":["技术探究"],"categories":["技术"]},{"title":"docker","url":"/2019/11/26/docker/","content":"\n***开一个新坑***\n\n// 学完没啥整理的欲望。。。还是太浅了\n\n","tags":["技术探究"],"categories":["技术"]},{"title":"Start！","url":"/2019/11/25/Start/","content":"\n总之还是决定开始写博客。 // 虽然还是偷懒用了GitHub Page\n\n算法笔记：[algorithm](https://mikyming.gitee.io/algorithm-docsify)\n\n本博客已经迁移，在完成搭建前不定时更新。\n\n联系请通过邮件。\n\n\n\n","tags":["瞎写"],"categories":["随笔"]},{"title":"Hello world","url":"/2019/11/25/Hello world/","content":"\n博客的大致框架：\n\tcategoies: 技术 随笔 读书\n\ttags: [技术探究] [解决方案] [思考] [随笔]\n\n<!--more-->\n\n这里啥也没有。","tags":["随笔"],"categories":["随笔"]}]